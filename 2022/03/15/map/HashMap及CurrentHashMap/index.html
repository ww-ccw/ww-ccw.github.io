

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="chw">
  <meta name="keywords" content="技术博客">
  
    <meta name="description" content="分析HashMap及CurrentHashMap源码">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap及CurrentHashMap详解">
<meta property="og:url" content="https://ww-ccw.github.io/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/index.html">
<meta property="og:site_name" content="CHW的博客">
<meta property="og:description" content="分析HashMap及CurrentHashMap源码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ww-ccw.github.io/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYWQ5OWNmNTRiN2RkNDI2NjIzMDE1ODY3NDI1ODUucG5n">
<meta property="og:image" content="https://ww-ccw.github.io/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMzkyNTZmOTVhOGFiMjEzNTcxMDE1ODcwNTIxNjgucG5n">
<meta property="og:image" content="https://ww-ccw.github.io/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/20180920225826285">
<meta property="og:image" content="https://ww-ccw.github.io/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMTY1MGYwYjMzMzFmMTBlNWFlMDE1ODczNTQwNDgucG5n">
<meta property="article:published_time" content="2022-03-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-07T02:45:37.329Z">
<meta property="article:author" content="chw">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ww-ccw.github.io/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYWQ5OWNmNTRiN2RkNDI2NjIzMDE1ODY3NDI1ODUucG5n">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>HashMap及CurrentHashMap详解 - CHW的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ww-ccw.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CHW的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="HashMap及CurrentHashMap详解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-15 00:00" pubdate>
          2022年3月15日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">HashMap及CurrentHashMap详解</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYWQ5OWNmNTRiN2RkNDI2NjIzMDE1ODY3NDI1ODUucG5n" srcset="/img/loading.gif" lazyload alt="hashmap在1.8"></p>
<p>hashmap中基础架构</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，</span>
<span class="hljs-comment">* 如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），</span>
<span class="hljs-comment">* 需要抛出异常ConcurrentModificationException</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;

<span class="hljs-comment">//默认的初始化容量为16，必须是2的n次幂</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span>

<span class="hljs-comment">//最大容量为 2^30</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;

<span class="hljs-comment">//默认的加载因子0.75，乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容。</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;

<span class="hljs-comment">//刚才提到了当链表长度过长时，会有一个阈值，超过这个阈值8就会转化为红黑树</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;

<span class="hljs-comment">//当红黑树上的元素个数，减少到6个时，就退化为链表</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;

<span class="hljs-comment">//链表转化为红黑树，除了有阈值的限制，还有另外一个限制，需要数组容量至少达到64，才会树化。</span>
<span class="hljs-comment">//这是为了避免，数组扩容和树化阈值之间的冲突。</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;

<span class="hljs-comment">//存放所有Node节点的数组</span>
<span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;

<span class="hljs-comment">//存放所有的键值对</span>
<span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

<span class="hljs-comment">//map中的实际键值对个数，即数组中元素个数</span>
<span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;

<span class="hljs-comment">//每次结构改变时，都会自增，fail-fast机制，这是一种错误检测机制。</span>
<span class="hljs-comment">//当迭代集合的时候，如果结构发生改变，则会发生 fail-fast，抛出异常。</span>
<span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;

<span class="hljs-comment">//数组扩容阈值</span>
<span class="hljs-type">int</span> threshold;

<span class="hljs-comment">//加载因子</span>
<span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;					

<span class="hljs-comment">//普通单向链表节点类</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;
	<span class="hljs-comment">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span>
	<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;
	<span class="hljs-keyword">final</span> K key;
	V value;
	<span class="hljs-comment">//指向单链表的下一个节点</span>
	Node&lt;K,V&gt; next;

	Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
		<span class="hljs-built_in">this</span>.hash = hash;
		<span class="hljs-built_in">this</span>.key = key;
		<span class="hljs-built_in">this</span>.value = value;
		<span class="hljs-built_in">this</span>.next = next;
	&#125;
&#125;

<span class="hljs-comment">//转化为红黑树的节点类</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;
	<span class="hljs-comment">//当前节点的父节点</span>
	TreeNode&lt;K,V&gt; parent;  
	<span class="hljs-comment">//左孩子节点</span>
	TreeNode&lt;K,V&gt; left;
	<span class="hljs-comment">//右孩子节点</span>
	TreeNode&lt;K,V&gt; right;
	<span class="hljs-comment">//指向前一个节点</span>
	TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span>
	<span class="hljs-comment">//当前节点是红色或者黑色的标识</span>
	<span class="hljs-type">boolean</span> red;
	TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;
		<span class="hljs-built_in">super</span>(hash, key, val, next);
	&#125;
&#125;</code></pre></div>



<h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><ol>
<li><p>创建一个默认负载因子的对象</p>
 <div class="code-wrapper"><pre><code class="hljs java">/
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span>

<span class="hljs-comment">//构造一个具有默认初始容量(16)和默认负载因子(0.75)的空HashMap。</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>
&#125;</code></pre></div></li>
</ol>
<h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将指定值与此映射中的指定键关联。如果先前的映射包含键的映射，则替换旧值。</span>
<span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;
    <span class="hljs-comment">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，用于确定当前key应该存放在数组的哪个下标位置</span>
    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
&#125;

<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span>
<span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;
    	<span class="hljs-comment">//懒加载初始化</span>
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;
    	<span class="hljs-comment">//判断table是否为空，如果空的话，会先调用resize扩容</span>
        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
            n = (tab = resize()).length;
    	<span class="hljs-comment">//根据当前key的hash值找到它在数组中的下标，判断当前下标位置是否已经存在元素，</span>
		<span class="hljs-comment">//若没有，则把key、value包装成Node节点，直接添加到此位置。</span>
        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)
            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//如果当前位置已经有元素了，分为三种情况。</span>
            Node&lt;K,V&gt; e; K k;
            <span class="hljs-comment">//1.当前位置元素的hash值等于传过来的hash，并且他们的key值也相等，</span>
            <span class="hljs-comment">//则把p赋值给e，跳转到①处，后续需要做值的覆盖处理</span>
            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
                e = p;
            <span class="hljs-comment">//2.如果当前是红黑树结构，则把它加入到红黑树 </span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);
            <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//3.说明此位置已存在元素，并且是普通链表结构，则采用尾插法，把新节点加入到链表尾部</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;
                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;
                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);
                        <span class="hljs-comment">//如果在插入的过程中，链表长度超过了8，则转化为红黑树</span>
                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// ============================转换成树</span>
                            treeifyBin(tab, hash);
                        <span class="hljs-keyword">break</span>;
                    &#125;
                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
                        <span class="hljs-comment">//若在链表中找到了相同key的话，直接退出循环，跳转到①处</span>
                        <span class="hljs-keyword">break</span>;
                    p = e;
                &#125;
            &#125;
            <span class="hljs-comment">//①</span>
            <span class="hljs-comment">//说明发生了碰撞，e代表的是旧值，因此节点位置不变，但是需要替换为新值</span>
            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>
                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;
                <span class="hljs-comment">//用新值替换旧值，并返回旧值。</span>
                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)
                    e.value = value;
                <span class="hljs-comment">//看方法名字即可知，这是在node被访问之后需要做的操作。其实此处是一个空实现，</span>
                <span class="hljs-comment">//只有在 LinkedHashMap才会实现，用于实现根据访问先后顺序对元素进行排序，hashmap不提供排序功能</span>
                afterNodeAccess(e);
                <span class="hljs-keyword">return</span> oldValue;
            &#125;
        &#125;
    	<span class="hljs-comment">//快速失败策略，每次对hashmap进行修改的时候这个参数都会自增</span>
        ++modCount;
    	<span class="hljs-comment">//如果当前数组中的元素个数超过阈值，则扩容</span>
	    <span class="hljs-keyword">if</span> (++size &gt; threshold)
            resize();
    	<span class="hljs-comment">//同样的空实现</span>
        afterNodeInsertion(evict);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    &#125;</code></pre></div>

<h3 id="hash-计算"><a href="#hash-计算" class="headerlink" title="hash()计算"></a>hash()计算</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;
	<span class="hljs-type">int</span> h;
	<span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
&#125;</code></pre></div>

<h3 id="resize（）"><a href="#resize（）" class="headerlink" title="resize（）"></a>resize（）</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;
    <span class="hljs-comment">//旧数组</span>
    Node&lt;K,V&gt;[] oldTab = table;
    <span class="hljs-comment">//旧数组的容量</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;
    <span class="hljs-comment">//旧数组的扩容阈值，注意看，这里取的是当前对象的 threshold 值，下边的第2种情况会用到。</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;
    <span class="hljs-comment">//初始化新数组的容量和阈值，分三种情况讨论。</span>
    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//1.当旧数组的容量大于0时，说明在这之前肯定调用过 resize扩容过一次，才会导致旧容量不为0。</span>
    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//容量达到了最大值</span>
        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            <span class="hljs-keyword">return</span> oldTab;
        &#125;
        <span class="hljs-comment">//新数组的容量和阈值都扩大原来的2倍</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>
    &#125;
    <span class="hljs-comment">//2.到这里，说明 oldCap &lt;= 0，并且 oldThr(threshold) &gt; 0，这就是 map 初始化的时候，第一次调用 resize的情况</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>
        newCap = oldThr;
    <span class="hljs-comment">//3.到这里，说明 oldCap 和 oldThr 都是小于等于0的。也说明我们的map是通过默认无参构造来创建的，</span>
    <span class="hljs-comment">//于是，数组的容量和阈值都取默认值就可以了，即 16 和 12。</span>
    <span class="hljs-keyword">else</span> &#123;               
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    
    <span class="hljs-comment">//③ 这里就是处理第2种情况，因为只有这种情况 newThr 才为0，</span>
	<span class="hljs-comment">//因此计算 newThr（用 newCap即16 乘以加载因子 0.75，得到 12） ，并把它赋值给 threshold</span>
    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?
                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);
    &#125;
    <span class="hljs-comment">//赋予 threshold 正确的值，表示数组下次需要扩容的阈值（此时就把原来的 16 修正为了 12）。</span>
    threshold = newThr;
    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>
    <span class="hljs-comment">//在构造函数时，并没有创建数组，在第一次调用put方法，导致resize的时候，才会把数组创建出来。这是为了懒加载，提高效率。</span>
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];
    table = newTab;
    
    
    <span class="hljs-comment">//如果原来的数组不为空，那么我们就需要把原来数组中的元素重新分配到新的数组中</span>
	<span class="hljs-comment">//如果是第2种情况，由于是第一次调用resize，此时数组肯定是空的，因此也就不需要重新分配元素。</span>
    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            <span class="hljs-comment">//取到当前下标的第一个元素，如果存在，则分三种情况重新分配位置</span>
            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;
                oldTab[j] = <span class="hljs-literal">null</span>;
                <span class="hljs-comment">//1.如果当前元素的下一个元素为空，则说明此处只有一个元素</span>
                <span class="hljs-comment">//则直接用它的hash()值和新数组的容量取模就可以了，得到新的下标位置。</span>
                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)
                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;
                
                <span class="hljs-comment">//2.如果是红黑树结构，则拆分红黑树，必要时有可能退化为链表</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);
                
                <span class="hljs-comment">//3.到这里说明，这是一个长度大于 1 的普通链表，则需要计算并</span>
                <span class="hljs-comment">//判断当前位置的链表是否需要移动到新的位置</span>
                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>
                    <span class="hljs-comment">// loHead 和 loTail 分别代表链表旧位置的头尾节点</span>
                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;
                    <span class="hljs-comment">// hiHead 和 hiTail 分别代表链表移动到新位置的头尾节点</span>
                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;
                    Node&lt;K,V&gt; next;
                    <span class="hljs-keyword">do</span> &#123;
                        next = e.next;
                        <span class="hljs-comment">//如果当前元素的hash值和oldCap做与运算为0，则原位置不变</span>
                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;
                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)
                                loHead = e;
                            <span class="hljs-keyword">else</span>
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        <span class="hljs-comment">//否则，需要移动到新的位置</span>
                        <span class="hljs-keyword">else</span> &#123;
                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)
                                hiHead = e;
                            <span class="hljs-keyword">else</span>
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);
                    <span class="hljs-comment">//原位置不变的一条链表，数组下标不变</span>
                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;
                        loTail.next = <span class="hljs-literal">null</span>;
                        newTab[j] = loHead;
                    &#125;
                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;
                        hiTail.next = <span class="hljs-literal">null</span>;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">//移动到新位置的一条链表，数组下标为原下标加上旧数组的容量</span>
    <span class="hljs-keyword">return</span> newTab;
&#125;</code></pre></div>

<h3 id="get（）"><a href="#get（）" class="headerlink" title="get（）"></a>get（）</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;
    Node&lt;K,V&gt; e;
    <span class="hljs-comment">//如果节点为空，则返回null，否则返回节点的value。这也说明，hashMap是支持value为null的。</span>
    <span class="hljs-comment">//因此，我们就明白了，为什么hashMap支持Key和value都为null</span>
    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;
&#125;

<span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;
    <span class="hljs-comment">//首先要确保数组不能为空，然后取到当前hash值计算出来的下标位置的第一个元素</span>
    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;
        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">//若hash值和key都相等，则说明我们要找的就是第一个元素，直接返回</span>
        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>
            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
            <span class="hljs-keyword">return</span> first;
        <span class="hljs-comment">//如果不是的话，就遍历当前链表（或红黑树）</span>
        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-comment">//如果是红黑树结构，则找到当前key所在的节点位置</span>
            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)
                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            <span class="hljs-comment">//如果是普通链表，则向后遍历查找，直到找到或者遍历到链表末尾为止。</span>
            <span class="hljs-keyword">do</span> &#123;
                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
                    <span class="hljs-keyword">return</span> e;
            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);
        &#125;
    &#125;
    <span class="hljs-comment">//否则，说明没有找到，返回null</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;
</code></pre></div>

<h3 id="快速失败原理"><a href="#快速失败原理" class="headerlink" title="快速失败原理"></a>快速失败原理</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span>
    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;V&gt; &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> nextNode().value; &#125;
&#125;

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span> &#123;
    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span>
    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span>
    <span class="hljs-type">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span>
    <span class="hljs-type">int</span> index;             <span class="hljs-comment">// current slot</span>

    HashIterator() &#123;
        <span class="hljs-comment">//在构造迭代器的时候，将modCount值赋值给expectedModCount</span>
        expectedModCount = modCount;
        Node&lt;K,V&gt;[] t = table;
        current = next = <span class="hljs-literal">null</span>;
        index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span>
            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;
    &#125;

    <span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">nextNode</span><span class="hljs-params">()</span> &#123;
        Node&lt;K,V&gt;[] t;
        Node&lt;K,V&gt; e = next;
        <span class="hljs-comment">//在获取下一个节点前，先判定modCount值是否修改，如果被修改了则抛出ConcurrentModificationException异常，从前面可以知道，当修改了HashMap的时候，都会修改modCount值。</span>
        <span class="hljs-keyword">if</span> (modCount != expectedModCount)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();
        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-literal">null</span> &amp;&amp; (t = table) != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);
        &#125;
        <span class="hljs-keyword">return</span> e;
    &#125;

    <span class="hljs-comment">//迭代器的删除操作，会重新给exceptedModCount赋值，因此不会导致fast-fail</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;
        Node&lt;K,V&gt; p = current;
        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();
        <span class="hljs-comment">//先判定modCount值是否被修改了</span>
        <span class="hljs-keyword">if</span> (modCount != expectedModCount)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();
        current = <span class="hljs-literal">null</span>;
        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> p.key;
        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
        <span class="hljs-comment">//将modCount值重新赋值给expectedModCount，这样下次迭代时，不会出现fast-fail</span>
        expectedModCount = modCount;
    &#125;
&#125;
</code></pre></div>

<p>每次修改hashmap的时候，modCount都会自增一次，而迭代器迭代下一个元素之前都会比较modCount，如果不一样则说明已经被修改了，于是直接抛出错误。</p>
<h3 id="主要变化及原理解释"><a href="#主要变化及原理解释" class="headerlink" title="主要变化及原理解释"></a>主要变化及原理解释</h3><h4 id="为什么要改成“数组-链表-红黑树”？"><a href="#为什么要改成“数组-链表-红黑树”？" class="headerlink" title="为什么要改成“数组+链表+红黑树”？"></a>为什么要改成“数组+链表+红黑树”？</h4><p>主要是为了提升在hash冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</p>
<h4 id="链表红黑树之间的转换"><a href="#链表红黑树之间的转换" class="headerlink" title="链表红黑树之间的转换"></a>链表红黑树之间的转换</h4><p>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</p>
<p>对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。</p>
<h4 id="为什么链表转红黑树的阈值是8？"><a href="#为什么链表转红黑树的阈值是8？" class="headerlink" title="为什么链表转红黑树的阈值是8？"></a>为什么链表转红黑树的阈值是8？</h4><p>红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价作者觉得不值得。</p>
<h4 id="为什么转回链表节点是用的6而不是复用8？"><a href="#为什么转回链表节点是用的6而不是复用8？" class="headerlink" title="为什么转回链表节点是用的6而不是复用8？"></a>为什么转回链表节点是用的6而不是复用8？</h4><p>如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在8徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗。</p>
<h4 id="HashMap-的初始容量是多少？"><a href="#HashMap-的初始容量是多少？" class="headerlink" title="HashMap 的初始容量是多少？"></a>HashMap 的初始容量是多少？</h4><p>默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16。</p>
<h4 id="介绍一下死循环问题"><a href="#介绍一下死循环问题" class="headerlink" title="介绍一下死循环问题"></a>介绍一下死循环问题</h4><p>导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMzkyNTZmOTVhOGFiMjEzNTcxMDE1ODcwNTIxNjgucG5n" srcset="/img/loading.gif" lazyload alt="JDK7的ConcurrentHashMap"></p>
<p>从整体来看，它是一个由 Segment 组成的数组。然后，每个 Segment 里边是由 HashEntry 组成的数组，每个 HashEntry之间又可以形成链表。我们可以把每个 Segment 看成是一个小的 HashMap，其内部结构和 HashMap 是一模一样的。ConcurrentHashMap的segment一经创建数量就不会再改变。</p>
<p>ReentrantLock+CAS+分段思想来保证的并发安全的，ConcurrentHashMap的put方法会通过CAS的方式，把一个Segment对象存到Segment数组中，一个Segment内部存在一个HashEntry数组，相当于分段的HashMap，Segment继承了ReentrantLock，每段put开始会加锁。故而称之为分段锁。</p>
<h4 id="Put（）"><a href="#Put（）" class="headerlink" title="Put（）"></a>Put（）</h4><ol>
<li>通过哈希算法计算出当前 key 的 hash 值</li>
<li>通过这个 hash 值找到它所对应的 Segment 数组的下标，使用ReentrantLock的tryLock（）进行抢占锁</li>
<li>再通过 hash 值计算出它在对应 Segment 的 HashEntry数组 的下标</li>
<li>找到合适的位置使用CAS插入元素</li>
</ol>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>当 put 方法时，发现元素个数超过了阈值，则会扩容。需要注意的是，每个Segment只管它自己的扩容，互相之间并不影响。换句话说，可以出现这个 Segment的长度为2，另一个Segment的长度为4的情况（只要是2的n次幂）。</p>
<p>JDK7中的ConcurrentHashMap和JDK7的HashMap的扩容是不太一样的，首先JDK7中也是支持多线程扩容的，原因是，JDK7中的ConcurrentHashMap分段了，每一段叫做Segment对象，每个Segment对象相当于一个HashMap，分段之后，对于ConcurrentHashMap而言，能同时支持多个线程进行操作，前提是这些操作的是不同的Segment，而ConcurrentHashMap中的扩容是仅限于本Segment，也就是对应的小型HashMap进行扩容，所以是可以多线程扩容的。</p>
<p>每个Segment内部的扩容逻辑和HashMap中一样。</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/20180920225826285" srcset="/img/loading.gif" lazyload alt="JDK8 ConcurrentHashMap"></p>
<p>JDK 1.8 的 CHM（ConcurrentHashMap） 实现，完全重构了 1.7 。<strong>不再有 Segment 的概念</strong>，只是为了兼容 1.7 才申明了一下，并没有用到。因此，<strong>不再使用分段锁，而是给数组中的每一个头节点</strong>（为了方便，以后都叫桶）都加锁，<strong>锁的粒度降低了</strong>。并且，用的是 Synchronized 锁。</p>
<p>JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//  扩容用  计算扩容生成一个标识戳</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;
<span class="hljs-comment">// 65535 标识并发扩容最大线程数量</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RESIZERS</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">32</span> - RESIZE_STAMP_BITS)) - <span class="hljs-number">1</span>;
<span class="hljs-comment">// 扩容相关</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_SHIFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span> - RESIZE_STAMP_BITS;
<span class="hljs-comment">// node 结点的hash 是-1 表示 当前结点是forwardingNode结点</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOVED</span>     <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// hash for forwarding nodes</span>
<span class="hljs-comment">// 红黑树的代理结点</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEBIN</span>   <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>; <span class="hljs-comment">// hash for roots of trees</span>
<span class="hljs-comment">// 临时保留的散列表</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESERVED</span>  <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>; <span class="hljs-comment">// hash for transient reservations</span>
<span class="hljs-comment">// 0x7fffffff = 31个1  用于将一个负数变成一个正数 但是不是取绝对值</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// usable bits of normal node hash</span>
<span class="hljs-comment">// 系统cpu数量</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NCPU</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();
<span class="hljs-comment">// 散列表</span>
<span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;
<span class="hljs-comment">// 扩容用的临时散列表</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;
<span class="hljs-comment">// LongAdder 的baseCount </span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> baseCount;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">sizeCtl &lt;0 </span>
<span class="hljs-comment">	1. -1 的时候 表示table正在初始化(有线程正在初始化 ， 当前线程应该自旋等待)</span>
<span class="hljs-comment">	2. 其他情况 表示当前map正在进行扩容 高16位表示 扩容的标识戳 ， 低16位表示 扩容线程数量</span>
<span class="hljs-comment">sizeCtl = 0 </span>
<span class="hljs-comment">	表示创建数组 使用默认容量 16</span>
<span class="hljs-comment">sizeCtl &gt;0</span>
<span class="hljs-comment">	1. 如果table 未初始化 表示 初始化大小</span>
<span class="hljs-comment">	2. 如果table 已经初始化 表示下次扩容的阈值</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;
<span class="hljs-comment">//扩容过程中，记录当前进度，所有线程都需要从transferIndex中分配区间任务，去执行自己的任务</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> transferIndex;
<span class="hljs-comment">// 0 表示 无锁 1 表示加锁</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;
 <span class="hljs-comment">// LongAdder 中的cells 数组 当baseCount发生竞争后 会创建cells 数组</span>
 <span class="hljs-comment">// 线程会通过计算hash值 取到自己的cell中</span>
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> CounterCell[] counterCells;

<span class="hljs-comment">//标记作用，表示其他线程正在扩容，并且此节点已经扩容完毕</span>
<span class="hljs-comment">//关联了nextTable,扩容期间可以通过find方法，访问已经迁移到了nextTable中的数据</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;
    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;
    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;
        <span class="hljs-comment">//hash值为MOVED（-1）的节点就是ForwardingNode</span>
        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
        <span class="hljs-built_in">this</span>.nextTable = tab;
    &#125;
    <span class="hljs-comment">//通过此方法，访问被迁移到nextTable中的数据</span>
    Node&lt;K,V&gt; <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> h, Object k)</span> &#123;
        ...
    &#125;
&#125;</code></pre></div>



<h4 id="Put（）-1"><a href="#Put（）-1" class="headerlink" title="Put（）"></a>Put（）</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;
    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);
&#125;

<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;
    <span class="hljs-comment">//可以看到，在并发情况下，key 和 value 都是不支持为空的。</span>
    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();
    <span class="hljs-comment">//这里和1.8 HashMap 的hash 方法大同小异</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());
    <span class="hljs-comment">//用来计算当前链表上的元素个数</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;
        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;
        <span class="hljs-comment">//若表为空，则说明还未初始化。</span>
        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
            <span class="hljs-comment">//初始化表，只有一个线程可以初始化成功。</span>
            tab = initTable();
        <span class="hljs-comment">//若表已经初始化，则找到当前 key 所在的桶，并且判断是否为空</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-comment">//若当前桶为空，则通过 CAS 原子操作，把新节点插入到此位置，</span>
            <span class="hljs-comment">//这保证了只有一个线程可以 CAS 成功，其它线程都会失败。</span>
            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,
                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))
                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>
        &#125;
        <span class="hljs-comment">//若所在桶不为空，则判断节点的 hash 值是否为 MOVED（值是-1）</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)
            <span class="hljs-comment">//若为-1，说明当前数组正在进行扩容，则需要当前线程帮忙迁移数据</span>
            tab = helpTransfer(tab, f);
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
            <span class="hljs-comment">//这里用加同步锁的方式，来保证线程安全，给桶中第一个节点对象加锁</span>
            <span class="hljs-keyword">synchronized</span> (f) &#123;
                <span class="hljs-comment">//recheck 一下，保证当前桶的第一个节点无变化，后边很多这样类似的操作，不再赘述</span>
                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;
                    <span class="hljs-comment">//如果hash值大于等于0，说明是正常的链表结构</span>
                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;
                        binCount = <span class="hljs-number">1</span>;
                        <span class="hljs-comment">//从头结点开始遍历，每遍历一次，binCount计数加1</span>
                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                            K ek;
                            <span class="hljs-comment">//如果找到了和当前 key 相同的节点，则用新值替换旧值</span>
                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;
                                oldVal = e.val;
                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                    e.val = value;
                                <span class="hljs-keyword">break</span>;
                            &#125;
                            Node&lt;K,V&gt; pred = e;
                            <span class="hljs-comment">//若遍历到了尾结点，则把新节点尾插进去</span>
                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;
                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,
                                                          value, <span class="hljs-literal">null</span>);
                                <span class="hljs-keyword">break</span>;
                            &#125;
                        &#125;
                    &#125;
                    <span class="hljs-comment">//否则判断是否是树节点。这里提一下，TreeBin只是头结点对TreeNode的再封装</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;
                        Node&lt;K,V&gt; p;
                        binCount = <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                              value)) != <span class="hljs-literal">null</span>) &#123;
                            oldVal = p.val;
                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                p.val = value;
                        &#125;
                    &#125;
                &#125;
            &#125;
            <span class="hljs-comment">//注意下，这个判断是在同步锁外部，因为 treeifyBin内部也有同步锁，并不影响</span>
            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">//如果节点个数大于等于 8，则转化为红黑树</span>
                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                <span class="hljs-comment">//把旧节点值返回</span>
                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)
                    <span class="hljs-keyword">return</span> oldVal;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">//给元素个数加 1，并有可能会触发扩容，比较复杂，稍后细讲</span>
    addCount(<span class="hljs-number">1L</span>, binCount);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;
</code></pre></div>

<h4 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer()方法"></a>transfer()方法</h4><p>扩容方法</p>
<p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMTY1MGYwYjMzMzFmMTBlNWFlMDE1ODczNTQwNDgucG5n" srcset="/img/loading.gif" lazyload alt="其他线程帮助扩容"></p>
<p>为了方便，上边以原数组长度 8 为例。在元素迁移的时候，所有线程都遵循从后向前推进的规则，即如图A线程是第一个进来的线程，会从下标为7的位置，开始迁移数据。</p>
<p>而且当前线程迁移时会确定一个范围，限定它此次迁移的数据范围，如图 A 线程只能迁移 bound&#x3D;6到 i&#x3D;7 这两个数据。</p>
<p>此时，其它线程就不能迁移这部分数据了，只能继续向前推进，寻找其它可以迁移的数据范围，且每次推进的步长为固定值 stride（此处假设为2）。如图中 B线程发现 A 线程正在迁移6,7的数据，因此只能向前寻找，然后迁移 bound&#x3D;4 到 i&#x3D;5 的这两个数据。</p>
<p>当每个线程迁移完成它的范围内数据时，都会继续向前推进。那什么时候是个头呢？</p>
<p>这就需要维护一个全局的变量 transferIndex，来表示所有线程总共推进到的元素下标位置。如图，线程 A 第一次迁移成功后又向前推进，然后迁移2,3 的数据。此时，若没有其他线程在帮助迁移，则 transferIndex 即为2。</p>
<p>剩余部分等待下一个线程来迁移，或者有任何的 A 和B线程已经迁移完成，也可以推进到这里帮助迁移。直到 transferIndex&#x3D;0 。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个类是一个标志，用来代表当前桶（数组中的某个下标位置）的元素已经全部迁移完成</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;
    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;
    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;
        <span class="hljs-comment">//把当前桶的头结点的 hash 值设置为 -1，表明已经迁移完成，</span>
        <span class="hljs-comment">//这个节点中并不存储有效的数据</span>
        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
        <span class="hljs-built_in">this</span>.nextTable = tab;
    &#125;
&#125;

<span class="hljs-comment">//迁移数据</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;
    <span class="hljs-comment">//根据当前CPU核心数，确定每次推进的步长，最小值为16.（为了方便我们以2为例）</span>
    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span>
    <span class="hljs-comment">//从 addCount 方法，只会有一个线程跳转到这里，初始化新数组</span>
    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span>
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
            <span class="hljs-comment">//新数组长度为原数组的两倍</span>
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];
            nextTab = nt;
        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span>
            sizeCtl = Integer.MAX_VALUE;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">//用 nextTable 指代新数组</span>
        nextTable = nextTab;
        <span class="hljs-comment">//这里就把推进的下标值初始化为原数组长度（以16为例）</span>
        transferIndex = n;
    &#125;
    <span class="hljs-comment">//新数组长度</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;
    <span class="hljs-comment">//创建一个标志类</span>
    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);
    <span class="hljs-comment">//是否向前推进的标志</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;
    <span class="hljs-comment">//是否所有线程都全部迁移完成的标志</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span>
    <span class="hljs-comment">//i 代表当前线程正在迁移的桶的下标，bound代表它本次可以迁移的范围下限</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;
        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;
        <span class="hljs-comment">//需要向前推进</span>
        <span class="hljs-keyword">while</span> (advance) &#123;
            <span class="hljs-type">int</span> nextIndex, nextBound;
            <span class="hljs-comment">// (1) 先看 (3) 。i每次自减 1，直到 bound。若超过bound范围，或者finishing标志为true，则不用向前推进。</span>
            <span class="hljs-comment">//若未全部完成迁移，且 i 并未走到 bound，则跳转到 (7)，处理当前桶的元素迁移。</span>
            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)
                advance = <span class="hljs-literal">false</span>;
            <span class="hljs-comment">// (2) 每次执行，都会把 transferIndex 最新的值同步给 nextIndex</span>
            <span class="hljs-comment">//若 transferIndex小于等于0，则说明原数组中的每个桶位置，都有线程在处理迁移了，</span>
            <span class="hljs-comment">//于是，需要跳出while循环，并把 i设为 -1，以跳转到④判断在处理的线程是否已经全部完成。</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;
                i = -<span class="hljs-number">1</span>;
                advance = <span class="hljs-literal">false</span>;
            &#125;
            <span class="hljs-comment">// (3) 第一个线程会先走到这里，确定它的数据迁移范围。(2)处会更新 nextIndex为 transferIndex 的最新值</span>
            <span class="hljs-comment">//因此第一次 nextIndex=n=16，nextBound代表当次迁移的数据范围下限，减去步长即可，</span>
            <span class="hljs-comment">//所以，第一次时，nextIndex=16，nextBound=16-2=14。后续，每次都会间隔一个步长。</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt
                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex &gt; stride ?
                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;
                <span class="hljs-comment">//bound代表当次数据迁移下限</span>
                bound = nextBound;
                <span class="hljs-comment">//第一次的i为15，因为长度16的数组，最后一个元素的下标为15</span>
                i = nextIndex - <span class="hljs-number">1</span>;
                <span class="hljs-comment">//表明不需要向前推进，只有当把当前范围内的数据全部迁移完成后，才可以向前推进</span>
                advance = <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-comment">// (4)</span>
        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;
            <span class="hljs-type">int</span> sc;
            <span class="hljs-comment">//若全部线程迁移完成</span>
            <span class="hljs-keyword">if</span> (finishing) &#123;
                nextTable = <span class="hljs-literal">null</span>;
                <span class="hljs-comment">//更新table为新表</span>
                table = nextTab;
                <span class="hljs-comment">//扩容阈值改为原来数组长度的 3/2 ，即新长度的 3/4，也就是新数组长度的0.75倍</span>
                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);
                <span class="hljs-keyword">return</span>;
            &#125;
            <span class="hljs-comment">//到这，说明当前线程已经完成了自己的所有迁移（无论参与了几次迁移），</span>
            <span class="hljs-comment">//则把 sc 减1，表明参与扩容的线程数减少 1。</span>
            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;
                <span class="hljs-comment">//在 addCount 方法最后，我们强调，迁移开始时，会设置 sc=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span>
                <span class="hljs-comment">//每当有一个线程参与迁移，sc 就会加 1，每当有一个线程完成迁移，sc 就会减 1。</span>
                <span class="hljs-comment">//因此，这里就是去校验当前 sc 是否和初始值是否相等。相等，则说明全部线程迁移完成。</span>
                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    <span class="hljs-keyword">return</span>;
                <span class="hljs-comment">//只有此处，才会把finishing 设置为true。</span>
                finishing = advance = <span class="hljs-literal">true</span>;
                <span class="hljs-comment">//这里非常有意思，会把 i 从 -1 修改为16，</span>
                <span class="hljs-comment">//目的就是，让 i 再从后向前扫描一遍数组，检查是否所有的桶都已被迁移完成，参看 (6)</span>
                i = n; <span class="hljs-comment">// recheck before commit</span>
            &#125;
        &#125;
        <span class="hljs-comment">// (5) 若i的位置元素为空，则说明当前桶的元素已经被迁移完成，就把头结点设置为fwd标志。</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)
            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);
        <span class="hljs-comment">// (6) 若当前桶的头结点是 ForwardingNode ，说明迁移完成，则向前推进 </span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)
            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span>
        <span class="hljs-comment">//(7) 处理当前桶的数据迁移。</span>
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">synchronized</span> (f) &#123;  <span class="hljs-comment">//给头结点加锁</span>
                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;
                    Node&lt;K,V&gt; ln, hn;
                    <span class="hljs-comment">//若hash值大于等于0，则说明是普通链表节点</span>
                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;
                        <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;
                        <span class="hljs-comment">//这里是 1.7 的 CHM 的 rehash 方法和 1.8 HashMap的 resize 方法的结合体。</span>
                        <span class="hljs-comment">//会分成两条链表，一条链表和原来的下标相同，另一条链表是原来的下标加数组长度的位置</span>
                        <span class="hljs-comment">//然后找到 lastRun 节点，从它到尾结点整体迁移。</span>
                        <span class="hljs-comment">//lastRun前边的节点则单个迁移，但是需要注意的是，这里是头插法。</span>
                        <span class="hljs-comment">//另外还有一点和1.7不同，1.7 lastRun前边的节点是复制过去的，而这里是直接迁移的，没有复制操作。</span>
                        <span class="hljs-comment">//所以，最后会有两条链表，一条链表从 lastRun到尾结点是正序的，而lastRun之前的元素是倒序的，</span>
                        <span class="hljs-comment">//另外一条链表，从头结点开始就是倒叙的。看下图。</span>
                        Node&lt;K,V&gt; lastRun = f;
                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;
                            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;
                            <span class="hljs-keyword">if</span> (b != runBit) &#123;
                                runBit = b;
                                lastRun = p;
                            &#125;
                        &#125;
                        <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;
                            ln = lastRun;
                            hn = <span class="hljs-literal">null</span>;
                        &#125;
                        <span class="hljs-keyword">else</span> &#123;
                            hn = lastRun;
                            ln = <span class="hljs-literal">null</span>;
                        &#125;
                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;
                            <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;
                            <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)
                                ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);
                            <span class="hljs-keyword">else</span>
                                hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);
                        &#125;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = <span class="hljs-literal">true</span>;
                    &#125;
                    <span class="hljs-comment">//树节点</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;
                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
                        TreeNode&lt;K,V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;
                        TreeNode&lt;K,V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;
                        <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;
                            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;
                            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;
                                (h, e.key, e.val, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
                            <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;
                                <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-literal">null</span>)
                                    lo = p;
                                <span class="hljs-keyword">else</span>
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            &#125;
                            <span class="hljs-keyword">else</span> &#123;
                                <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-literal">null</span>)
                                    hi = p;
                                <span class="hljs-keyword">else</span>
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            &#125;
                        &#125;
                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                        (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;
                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                        (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = <span class="hljs-literal">true</span>;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre></div>

<h4 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer()"></a>helpTransfer()</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;
    Node&lt;K,V&gt;[] nextTab; <span class="hljs-type">int</span> sc;
    <span class="hljs-comment">//头结点为 ForwardingNode ，并且新数组已经初始化</span>
    <span class="hljs-keyword">if</span> (tab != <span class="hljs-literal">null</span> &amp;&amp; (f <span class="hljs-keyword">instanceof</span> ForwardingNode) &amp;&amp;
        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(tab.length);
        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;
               (sc = sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">//若校验标识失败，或者已经扩容完成，或推进下标到头，则退出</span>
            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||
                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">//当前线程需要帮助迁移，sc值加1</span>
            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;
                transfer(tab, nextTab);
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> nextTab;
    &#125;
    <span class="hljs-keyword">return</span> table;
&#125;
</code></pre></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在JDK8中，ConcurrentHashMap几乎全面改写</p>
<ol>
<li>Segment的代码虽然还存在，但是已经没有实际效果了，只是为了兼容JDK7</li>
<li>锁的粒度变得更小了，以前是通过锁Segment，现在移除了segment后变成了直接锁表头，效率变得更高了</li>
<li>锁的实现也改变了，以前锁segment的使用ReentrantLock并使用cas进行修改，JDK8变成了使用Synchronized 锁表头，由于Synchronized 进行优化后有了锁升级的过程所以效率并不低</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%BA%90%E7%A0%81/" class="category-chain-item">源码</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
        <a href="/tags/%E6%BA%90%E7%A0%81/">#源码</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>HashMap及CurrentHashMap详解</div>
      <div>https://ww-ccw.github.io/2022/03/15/map/HashMap及CurrentHashMap/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>chw</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/05/vue/vue2/" title="Vue2的学习笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue2的学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/05/redis/Redis/" title="Redis的学习笔记">
                        <span class="hidden-mobile">Redis的学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
