<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HashMap及CurrentHashMap详解</title>
    <link href="/2023/03/15/Map%E8%AF%A6%E8%A7%A3/HashMap%E5%8F%8ACurrentHashMap/"/>
    <url>/2023/03/15/Map%E8%AF%A6%E8%A7%A3/HashMap%E5%8F%8ACurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/2023/03/15/Map%E8%AF%A6%E8%A7%A3/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYWQ5OWNmNTRiN2RkNDI2NjIzMDE1ODY3NDI1ODUucG5n" alt="hashmap在1.8"></p><p>hashmap中基础架构</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，</span><span class="hljs-comment">* 如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），</span><span class="hljs-comment">* 需要抛出异常ConcurrentModificationException</span><span class="hljs-comment">*/</span><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<span class="hljs-comment">//默认的初始化容量为16，必须是2的n次幂</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">//最大容量为 2^30</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">//默认的加载因子0.75，乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容。</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<span class="hljs-comment">//刚才提到了当链表长度过长时，会有一个阈值，超过这个阈值8就会转化为红黑树</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//当红黑树上的元素个数，减少到6个时，就退化为链表</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<span class="hljs-comment">//链表转化为红黑树，除了有阈值的限制，还有另外一个限制，需要数组容量至少达到64，才会树化。</span><span class="hljs-comment">//这是为了避免，数组扩容和树化阈值之间的冲突。</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<span class="hljs-comment">//存放所有Node节点的数组</span><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="hljs-comment">//存放所有的键值对</span><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<span class="hljs-comment">//map中的实际键值对个数，即数组中元素个数</span><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">//每次结构改变时，都会自增，fail-fast机制，这是一种错误检测机制。</span><span class="hljs-comment">//当迭代集合的时候，如果结构发生改变，则会发生 fail-fast，抛出异常。</span><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<span class="hljs-comment">//数组扩容阈值</span><span class="hljs-type">int</span> threshold;<span class="hljs-comment">//加载因子</span><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<span class="hljs-comment">//普通单向链表节点类</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<span class="hljs-comment">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<span class="hljs-keyword">final</span> K key;V value;<span class="hljs-comment">//指向单链表的下一个节点</span>Node&lt;K,V&gt; next;Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<span class="hljs-built_in">this</span>.hash = hash;<span class="hljs-built_in">this</span>.key = key;<span class="hljs-built_in">this</span>.value = value;<span class="hljs-built_in">this</span>.next = next;&#125;&#125;<span class="hljs-comment">//转化为红黑树的节点类</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<span class="hljs-comment">//当前节点的父节点</span>TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">//左孩子节点</span>TreeNode&lt;K,V&gt; left;<span class="hljs-comment">//右孩子节点</span>TreeNode&lt;K,V&gt; right;<span class="hljs-comment">//指向前一个节点</span>TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><span class="hljs-comment">//当前节点是红色或者黑色的标识</span><span class="hljs-type">boolean</span> red;TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<span class="hljs-built_in">super</span>(hash, key, val, next);&#125;&#125;</code></pre></div><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><ol><li><p>创建一个默认负载因子的对象</p> <div class="code-wrapper"><pre><code class="hljs java">/<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">//构造一个具有默认初始容量(16)和默认负载因子(0.75)的空HashMap。</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>&#125;</code></pre></div></li></ol><h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将指定值与此映射中的指定键关联。如果先前的映射包含键的映射，则替换旧值。</span><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    <span class="hljs-comment">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，用于确定当前key应该存放在数组的哪个下标位置</span>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);&#125;<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;    <span class="hljs-comment">//懒加载初始化</span>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;    <span class="hljs-comment">//判断table是否为空，如果空的话，会先调用resize扩容</span>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            n = (tab = resize()).length;    <span class="hljs-comment">//根据当前key的hash值找到它在数组中的下标，判断当前下标位置是否已经存在元素，</span><span class="hljs-comment">//若没有，则把key、value包装成Node节点，直接添加到此位置。</span>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果当前位置已经有元素了，分为三种情况。</span>            Node&lt;K,V&gt; e; K k;            <span class="hljs-comment">//1.当前位置元素的hash值等于传过来的hash，并且他们的key值也相等，</span>            <span class="hljs-comment">//则把p赋值给e，跳转到①处，后续需要做值的覆盖处理</span>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                e = p;            <span class="hljs-comment">//2.如果当前是红黑树结构，则把它加入到红黑树 </span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//3.说明此位置已存在元素，并且是普通链表结构，则采用尾插法，把新节点加入到链表尾部</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);                        <span class="hljs-comment">//如果在插入的过程中，链表长度超过了8，则转化为红黑树</span>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// ============================转换成树</span>                            treeifyBin(tab, hash);                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                        <span class="hljs-comment">//若在链表中找到了相同key的话，直接退出循环，跳转到①处</span>                        <span class="hljs-keyword">break</span>;                    p = e;                &#125;            &#125;            <span class="hljs-comment">//①</span>            <span class="hljs-comment">//说明发生了碰撞，e代表的是旧值，因此节点位置不变，但是需要替换为新值</span>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;                <span class="hljs-comment">//用新值替换旧值，并返回旧值。</span>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)                    e.value = value;                <span class="hljs-comment">//看方法名字即可知，这是在node被访问之后需要做的操作。其实此处是一个空实现，</span>                <span class="hljs-comment">//只有在 LinkedHashMap才会实现，用于实现根据访问先后顺序对元素进行排序，hashmap不提供排序功能</span>                afterNodeAccess(e);                <span class="hljs-keyword">return</span> oldValue;            &#125;        &#125;    <span class="hljs-comment">//快速失败策略，每次对hashmap进行修改的时候这个参数都会自增</span>        ++modCount;    <span class="hljs-comment">//如果当前数组中的元素个数超过阈值，则扩容</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)            resize();    <span class="hljs-comment">//同样的空实现</span>        afterNodeInsertion(evict);        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;</code></pre></div><h3 id="hash-计算"><a href="#hash-计算" class="headerlink" title="hash()计算"></a>hash()计算</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<span class="hljs-type">int</span> h;<span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;</code></pre></div><h3 id="resize（）"><a href="#resize（）" class="headerlink" title="resize（）"></a>resize（）</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    <span class="hljs-comment">//旧数组</span>    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-comment">//旧数组的容量</span>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-comment">//旧数组的扩容阈值，注意看，这里取的是当前对象的 threshold 值，下边的第2种情况会用到。</span>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;    <span class="hljs-comment">//初始化新数组的容量和阈值，分三种情况讨论。</span>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-comment">//1.当旧数组的容量大于0时，说明在这之前肯定调用过 resize扩容过一次，才会导致旧容量不为0。</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//容量达到了最大值</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">//新数组的容量和阈值都扩大原来的2倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">//2.到这里，说明 oldCap &lt;= 0，并且 oldThr(threshold) &gt; 0，这就是 map 初始化的时候，第一次调用 resize的情况</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>        newCap = oldThr;    <span class="hljs-comment">//3.到这里，说明 oldCap 和 oldThr 都是小于等于0的。也说明我们的map是通过默认无参构造来创建的，</span>    <span class="hljs-comment">//于是，数组的容量和阈值都取默认值就可以了，即 16 和 12。</span>    <span class="hljs-keyword">else</span> &#123;                       newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;        <span class="hljs-comment">//③ 这里就是处理第2种情况，因为只有这种情况 newThr 才为0，</span><span class="hljs-comment">//因此计算 newThr（用 newCap即16 乘以加载因子 0.75，得到 12） ，并把它赋值给 threshold</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);    &#125;    <span class="hljs-comment">//赋予 threshold 正确的值，表示数组下次需要扩容的阈值（此时就把原来的 16 修正为了 12）。</span>    threshold = newThr;    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>    <span class="hljs-comment">//在构造函数时，并没有创建数组，在第一次调用put方法，导致resize的时候，才会把数组创建出来。这是为了懒加载，提高效率。</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];    table = newTab;            <span class="hljs-comment">//如果原来的数组不为空，那么我们就需要把原来数组中的元素重新分配到新的数组中</span><span class="hljs-comment">//如果是第2种情况，由于是第一次调用resize，此时数组肯定是空的，因此也就不需要重新分配元素。</span>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-comment">//取到当前下标的第一个元素，如果存在，则分三种情况重新分配位置</span>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;                <span class="hljs-comment">//1.如果当前元素的下一个元素为空，则说明此处只有一个元素</span>                <span class="hljs-comment">//则直接用它的hash()值和新数组的容量取模就可以了，得到新的下标位置。</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                                <span class="hljs-comment">//2.如果是红黑树结构，则拆分红黑树，必要时有可能退化为链表</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);                                <span class="hljs-comment">//3.到这里说明，这是一个长度大于 1 的普通链表，则需要计算并</span>                <span class="hljs-comment">//判断当前位置的链表是否需要移动到新的位置</span>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    <span class="hljs-comment">// loHead 和 loTail 分别代表链表旧位置的头尾节点</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// hiHead 和 hiTail 分别代表链表移动到新位置的头尾节点</span>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-comment">//如果当前元素的hash值和oldCap做与运算为0，则原位置不变</span>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-comment">//否则，需要移动到新的位置</span>                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-comment">//原位置不变的一条链表，数组下标不变</span>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">//移动到新位置的一条链表，数组下标为原下标加上旧数组的容量</span>    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre></div><h3 id="get（）"><a href="#get（）" class="headerlink" title="get（）"></a>get（）</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;    Node&lt;K,V&gt; e;    <span class="hljs-comment">//如果节点为空，则返回null，否则返回节点的value。这也说明，hashMap是支持value为null的。</span>    <span class="hljs-comment">//因此，我们就明白了，为什么hashMap支持Key和value都为null</span>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;&#125;<span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;    <span class="hljs-comment">//首先要确保数组不能为空，然后取到当前hash值计算出来的下标位置的第一个元素</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//若hash值和key都相等，则说明我们要找的就是第一个元素，直接返回</span>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-keyword">return</span> first;        <span class="hljs-comment">//如果不是的话，就遍历当前链表（或红黑树）</span>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//如果是红黑树结构，则找到当前key所在的节点位置</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-comment">//如果是普通链表，则向后遍历查找，直到找到或者遍历到链表末尾为止。</span>            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-comment">//否则，说明没有找到，返回null</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h3 id="快速失败原理"><a href="#快速失败原理" class="headerlink" title="快速失败原理"></a>快速失败原理</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;V&gt; &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> nextNode().value; &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span> &#123;    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span>    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span>    <span class="hljs-type">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span>    <span class="hljs-type">int</span> index;             <span class="hljs-comment">// current slot</span>    HashIterator() &#123;        <span class="hljs-comment">//在构造迭代器的时候，将modCount值赋值给expectedModCount</span>        expectedModCount = modCount;        Node&lt;K,V&gt;[] t = table;        current = next = <span class="hljs-literal">null</span>;        index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">nextNode</span><span class="hljs-params">()</span> &#123;        Node&lt;K,V&gt;[] t;        Node&lt;K,V&gt; e = next;        <span class="hljs-comment">//在获取下一个节点前，先判定modCount值是否修改，如果被修改了则抛出ConcurrentModificationException异常，从前面可以知道，当修改了HashMap的时候，都会修改modCount值。</span>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-literal">null</span> &amp;&amp; (t = table) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);        &#125;        <span class="hljs-keyword">return</span> e;    &#125;    <span class="hljs-comment">//迭代器的删除操作，会重新给exceptedModCount赋值，因此不会导致fast-fail</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;        Node&lt;K,V&gt; p = current;        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();        <span class="hljs-comment">//先判定modCount值是否被修改了</span>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();        current = <span class="hljs-literal">null</span>;        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> p.key;        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);        <span class="hljs-comment">//将modCount值重新赋值给expectedModCount，这样下次迭代时，不会出现fast-fail</span>        expectedModCount = modCount;    &#125;&#125;</code></pre></div><p>每次修改hashmap的时候，modCount都会自增一次，而迭代器迭代下一个元素之前都会比较modCount，如果不一样则说明已经被修改了，于是直接抛出错误。</p><h3 id="主要变化及原理解释"><a href="#主要变化及原理解释" class="headerlink" title="主要变化及原理解释"></a>主要变化及原理解释</h3><h4 id="为什么要改成“数组-链表-红黑树”？"><a href="#为什么要改成“数组-链表-红黑树”？" class="headerlink" title="为什么要改成“数组+链表+红黑树”？"></a>为什么要改成“数组+链表+红黑树”？</h4><p>主要是为了提升在hash冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</p><h4 id="链表红黑树之间的转换"><a href="#链表红黑树之间的转换" class="headerlink" title="链表红黑树之间的转换"></a>链表红黑树之间的转换</h4><p>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</p><p>对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。</p><h4 id="为什么链表转红黑树的阈值是8？"><a href="#为什么链表转红黑树的阈值是8？" class="headerlink" title="为什么链表转红黑树的阈值是8？"></a>为什么链表转红黑树的阈值是8？</h4><p>红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价作者觉得不值得。</p><h4 id="为什么转回链表节点是用的6而不是复用8？"><a href="#为什么转回链表节点是用的6而不是复用8？" class="headerlink" title="为什么转回链表节点是用的6而不是复用8？"></a>为什么转回链表节点是用的6而不是复用8？</h4><p>如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在8徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗。</p><h4 id="HashMap-的初始容量是多少？"><a href="#HashMap-的初始容量是多少？" class="headerlink" title="HashMap 的初始容量是多少？"></a>HashMap 的初始容量是多少？</h4><p>默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16。</p><h4 id="介绍一下死循环问题"><a href="#介绍一下死循环问题" class="headerlink" title="介绍一下死循环问题"></a>介绍一下死循环问题</h4><p>导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="/2023/03/15/Map%E8%AF%A6%E8%A7%A3/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMzkyNTZmOTVhOGFiMjEzNTcxMDE1ODcwNTIxNjgucG5n" alt="JDK7的ConcurrentHashMap"></p><p>从整体来看，它是一个由 Segment 组成的数组。然后，每个 Segment 里边是由 HashEntry 组成的数组，每个 HashEntry之间又可以形成链表。我们可以把每个 Segment 看成是一个小的 HashMap，其内部结构和 HashMap 是一模一样的。ConcurrentHashMap的segment一经创建数量就不会再改变。</p><p>ReentrantLock+CAS+分段思想来保证的并发安全的，ConcurrentHashMap的put方法会通过CAS的方式，把一个Segment对象存到Segment数组中，一个Segment内部存在一个HashEntry数组，相当于分段的HashMap，Segment继承了ReentrantLock，每段put开始会加锁。故而称之为分段锁。</p><h4 id="Put（）"><a href="#Put（）" class="headerlink" title="Put（）"></a>Put（）</h4><ol><li>通过哈希算法计算出当前 key 的 hash 值</li><li>通过这个 hash 值找到它所对应的 Segment 数组的下标，使用ReentrantLock的tryLock（）进行抢占锁</li><li>再通过 hash 值计算出它在对应 Segment 的 HashEntry数组 的下标</li><li>找到合适的位置使用CAS插入元素</li></ol><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>当 put 方法时，发现元素个数超过了阈值，则会扩容。需要注意的是，每个Segment只管它自己的扩容，互相之间并不影响。换句话说，可以出现这个 Segment的长度为2，另一个Segment的长度为4的情况（只要是2的n次幂）。</p><p>JDK7中的ConcurrentHashMap和JDK7的HashMap的扩容是不太一样的，首先JDK7中也是支持多线程扩容的，原因是，JDK7中的ConcurrentHashMap分段了，每一段叫做Segment对象，每个Segment对象相当于一个HashMap，分段之后，对于ConcurrentHashMap而言，能同时支持多个线程进行操作，前提是这些操作的是不同的Segment，而ConcurrentHashMap中的扩容是仅限于本Segment，也就是对应的小型HashMap进行扩容，所以是可以多线程扩容的。</p><p>每个Segment内部的扩容逻辑和HashMap中一样。</p><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><img src="/2023/03/15/Map%E8%AF%A6%E8%A7%A3/HashMap%E5%8F%8ACurrentHashMap/20180920225826285" alt="JDK8 ConcurrentHashMap"></p><p>JDK 1.8 的 CHM（ConcurrentHashMap） 实现，完全重构了 1.7 。<strong>不再有 Segment 的概念</strong>，只是为了兼容 1.7 才申明了一下，并没有用到。因此，<strong>不再使用分段锁，而是给数组中的每一个头节点</strong>（为了方便，以后都叫桶）都加锁，<strong>锁的粒度降低了</strong>。并且，用的是 Synchronized 锁。</p><p>JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//  扩容用  计算扩容生成一个标识戳</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<span class="hljs-comment">// 65535 标识并发扩容最大线程数量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RESIZERS</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">32</span> - RESIZE_STAMP_BITS)) - <span class="hljs-number">1</span>;<span class="hljs-comment">// 扩容相关</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_SHIFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span> - RESIZE_STAMP_BITS;<span class="hljs-comment">// node 结点的hash 是-1 表示 当前结点是forwardingNode结点</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOVED</span>     <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// hash for forwarding nodes</span><span class="hljs-comment">// 红黑树的代理结点</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEBIN</span>   <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>; <span class="hljs-comment">// hash for roots of trees</span><span class="hljs-comment">// 临时保留的散列表</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESERVED</span>  <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>; <span class="hljs-comment">// hash for transient reservations</span><span class="hljs-comment">// 0x7fffffff = 31个1  用于将一个负数变成一个正数 但是不是取绝对值</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// usable bits of normal node hash</span><span class="hljs-comment">// 系统cpu数量</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NCPU</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<span class="hljs-comment">// 散列表</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="hljs-comment">// 扩容用的临时散列表</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="hljs-comment">// LongAdder 的baseCount </span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> baseCount;<span class="hljs-comment">/**</span><span class="hljs-comment">sizeCtl &lt;0 </span><span class="hljs-comment">1. -1 的时候 表示table正在初始化(有线程正在初始化 ， 当前线程应该自旋等待)</span><span class="hljs-comment">2. 其他情况 表示当前map正在进行扩容 高16位表示 扩容的标识戳 ， 低16位表示 扩容线程数量</span><span class="hljs-comment">sizeCtl = 0 </span><span class="hljs-comment">表示创建数组 使用默认容量 16</span><span class="hljs-comment">sizeCtl &gt;0</span><span class="hljs-comment">1. 如果table 未初始化 表示 初始化大小</span><span class="hljs-comment">2. 如果table 已经初始化 表示下次扩容的阈值</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<span class="hljs-comment">//扩容过程中，记录当前进度，所有线程都需要从transferIndex中分配区间任务，去执行自己的任务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> transferIndex;<span class="hljs-comment">// 0 表示 无锁 1 表示加锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy; <span class="hljs-comment">// LongAdder 中的cells 数组 当baseCount发生竞争后 会创建cells 数组</span> <span class="hljs-comment">// 线程会通过计算hash值 取到自己的cell中</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> CounterCell[] counterCells;<span class="hljs-comment">//标记作用，表示其他线程正在扩容，并且此节点已经扩容完毕</span><span class="hljs-comment">//关联了nextTable,扩容期间可以通过find方法，访问已经迁移到了nextTable中的数据</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;        <span class="hljs-comment">//hash值为MOVED（-1）的节点就是ForwardingNode</span>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        <span class="hljs-built_in">this</span>.nextTable = tab;    &#125;    <span class="hljs-comment">//通过此方法，访问被迁移到nextTable中的数据</span>    Node&lt;K,V&gt; <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> h, Object k)</span> &#123;        ...    &#125;&#125;</code></pre></div><h4 id="Put（）-1"><a href="#Put（）-1" class="headerlink" title="Put（）"></a>Put（）</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);&#125;<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;    <span class="hljs-comment">//可以看到，在并发情况下，key 和 value 都是不支持为空的。</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();    <span class="hljs-comment">//这里和1.8 HashMap 的hash 方法大同小异</span>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());    <span class="hljs-comment">//用来计算当前链表上的元素个数</span>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;        <span class="hljs-comment">//若表为空，则说明还未初始化。</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            <span class="hljs-comment">//初始化表，只有一个线程可以初始化成功。</span>            tab = initTable();        <span class="hljs-comment">//若表已经初始化，则找到当前 key 所在的桶，并且判断是否为空</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//若当前桶为空，则通过 CAS 原子操作，把新节点插入到此位置，</span>            <span class="hljs-comment">//这保证了只有一个线程可以 CAS 成功，其它线程都会失败。</span>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">//若所在桶不为空，则判断节点的 hash 值是否为 MOVED（值是-1）</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            <span class="hljs-comment">//若为-1，说明当前数组正在进行扩容，则需要当前线程帮忙迁移数据</span>            tab = helpTransfer(tab, f);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-comment">//这里用加同步锁的方式，来保证线程安全，给桶中第一个节点对象加锁</span>            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-comment">//recheck 一下，保证当前桶的第一个节点无变化，后边很多这样类似的操作，不再赘述</span>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-comment">//如果hash值大于等于0，说明是正常的链表结构</span>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-comment">//从头结点开始遍历，每遍历一次，binCount计数加1</span>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-comment">//如果找到了和当前 key 相同的节点，则用新值替换旧值</span>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-comment">//若遍历到了尾结点，则把新节点尾插进去</span>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,                                                          value, <span class="hljs-literal">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">//否则判断是否是树节点。这里提一下，TreeBin只是头结点对TreeNode的再封装</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                              value)) != <span class="hljs-literal">null</span>) &#123;                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//注意下，这个判断是在同步锁外部，因为 treeifyBin内部也有同步锁，并不影响</span>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//如果节点个数大于等于 8，则转化为红黑树</span>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                <span class="hljs-comment">//把旧节点值返回</span>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//给元素个数加 1，并有可能会触发扩容，比较复杂，稍后细讲</span>    addCount(<span class="hljs-number">1L</span>, binCount);    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h4 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer()方法"></a>transfer()方法</h4><p>扩容方法</p><p><img src="/2023/03/15/Map%E8%AF%A6%E8%A7%A3/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMTY1MGYwYjMzMzFmMTBlNWFlMDE1ODczNTQwNDgucG5n" alt="其他线程帮助扩容"></p><p>为了方便，上边以原数组长度 8 为例。在元素迁移的时候，所有线程都遵循从后向前推进的规则，即如图A线程是第一个进来的线程，会从下标为7的位置，开始迁移数据。</p><p>而且当前线程迁移时会确定一个范围，限定它此次迁移的数据范围，如图 A 线程只能迁移 bound&#x3D;6到 i&#x3D;7 这两个数据。</p><p>此时，其它线程就不能迁移这部分数据了，只能继续向前推进，寻找其它可以迁移的数据范围，且每次推进的步长为固定值 stride（此处假设为2）。如图中 B线程发现 A 线程正在迁移6,7的数据，因此只能向前寻找，然后迁移 bound&#x3D;4 到 i&#x3D;5 的这两个数据。</p><p>当每个线程迁移完成它的范围内数据时，都会继续向前推进。那什么时候是个头呢？</p><p>这就需要维护一个全局的变量 transferIndex，来表示所有线程总共推进到的元素下标位置。如图，线程 A 第一次迁移成功后又向前推进，然后迁移2,3 的数据。此时，若没有其他线程在帮助迁移，则 transferIndex 即为2。</p><p>剩余部分等待下一个线程来迁移，或者有任何的 A 和B线程已经迁移完成，也可以推进到这里帮助迁移。直到 transferIndex&#x3D;0 。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个类是一个标志，用来代表当前桶（数组中的某个下标位置）的元素已经全部迁移完成</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;        <span class="hljs-comment">//把当前桶的头结点的 hash 值设置为 -1，表明已经迁移完成，</span>        <span class="hljs-comment">//这个节点中并不存储有效的数据</span>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        <span class="hljs-built_in">this</span>.nextTable = tab;    &#125;&#125;<span class="hljs-comment">//迁移数据</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;    <span class="hljs-comment">//根据当前CPU核心数，确定每次推进的步长，最小值为16.（为了方便我们以2为例）</span>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span>    <span class="hljs-comment">//从 addCount 方法，只会有一个线程跳转到这里，初始化新数组</span>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            <span class="hljs-comment">//新数组长度为原数组的两倍</span>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];            nextTab = nt;        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span>            sizeCtl = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//用 nextTable 指代新数组</span>        nextTable = nextTab;        <span class="hljs-comment">//这里就把推进的下标值初始化为原数组长度（以16为例）</span>        transferIndex = n;    &#125;    <span class="hljs-comment">//新数组长度</span>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;    <span class="hljs-comment">//创建一个标志类</span>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);    <span class="hljs-comment">//是否向前推进的标志</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//是否所有线程都全部迁移完成的标志</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span>    <span class="hljs-comment">//i 代表当前线程正在迁移的桶的下标，bound代表它本次可以迁移的范围下限</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;        <span class="hljs-comment">//需要向前推进</span>        <span class="hljs-keyword">while</span> (advance) &#123;            <span class="hljs-type">int</span> nextIndex, nextBound;            <span class="hljs-comment">// (1) 先看 (3) 。i每次自减 1，直到 bound。若超过bound范围，或者finishing标志为true，则不用向前推进。</span>            <span class="hljs-comment">//若未全部完成迁移，且 i 并未走到 bound，则跳转到 (7)，处理当前桶的元素迁移。</span>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)                advance = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// (2) 每次执行，都会把 transferIndex 最新的值同步给 nextIndex</span>            <span class="hljs-comment">//若 transferIndex小于等于0，则说明原数组中的每个桶位置，都有线程在处理迁移了，</span>            <span class="hljs-comment">//于是，需要跳出while循环，并把 i设为 -1，以跳转到④判断在处理的线程是否已经全部完成。</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;                i = -<span class="hljs-number">1</span>;                advance = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-comment">// (3) 第一个线程会先走到这里，确定它的数据迁移范围。(2)处会更新 nextIndex为 transferIndex 的最新值</span>            <span class="hljs-comment">//因此第一次 nextIndex=n=16，nextBound代表当次迁移的数据范围下限，减去步长即可，</span>            <span class="hljs-comment">//所以，第一次时，nextIndex=16，nextBound=16-2=14。后续，每次都会间隔一个步长。</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,                      nextBound = (nextIndex &gt; stride ?                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;                <span class="hljs-comment">//bound代表当次数据迁移下限</span>                bound = nextBound;                <span class="hljs-comment">//第一次的i为15，因为长度16的数组，最后一个元素的下标为15</span>                i = nextIndex - <span class="hljs-number">1</span>;                <span class="hljs-comment">//表明不需要向前推进，只有当把当前范围内的数据全部迁移完成后，才可以向前推进</span>                advance = <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-comment">// (4)</span>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;            <span class="hljs-type">int</span> sc;            <span class="hljs-comment">//若全部线程迁移完成</span>            <span class="hljs-keyword">if</span> (finishing) &#123;                nextTable = <span class="hljs-literal">null</span>;                <span class="hljs-comment">//更新table为新表</span>                table = nextTab;                <span class="hljs-comment">//扩容阈值改为原来数组长度的 3/2 ，即新长度的 3/4，也就是新数组长度的0.75倍</span>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//到这，说明当前线程已经完成了自己的所有迁移（无论参与了几次迁移），</span>            <span class="hljs-comment">//则把 sc 减1，表明参与扩容的线程数减少 1。</span>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;                <span class="hljs-comment">//在 addCount 方法最后，我们强调，迁移开始时，会设置 sc=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span>                <span class="hljs-comment">//每当有一个线程参与迁移，sc 就会加 1，每当有一个线程完成迁移，sc 就会减 1。</span>                <span class="hljs-comment">//因此，这里就是去校验当前 sc 是否和初始值是否相等。相等，则说明全部线程迁移完成。</span>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    <span class="hljs-keyword">return</span>;                <span class="hljs-comment">//只有此处，才会把finishing 设置为true。</span>                finishing = advance = <span class="hljs-literal">true</span>;                <span class="hljs-comment">//这里非常有意思，会把 i 从 -1 修改为16，</span>                <span class="hljs-comment">//目的就是，让 i 再从后向前扫描一遍数组，检查是否所有的桶都已被迁移完成，参看 (6)</span>                i = n; <span class="hljs-comment">// recheck before commit</span>            &#125;        &#125;        <span class="hljs-comment">// (5) 若i的位置元素为空，则说明当前桶的元素已经被迁移完成，就把头结点设置为fwd标志。</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);        <span class="hljs-comment">// (6) 若当前桶的头结点是 ForwardingNode ，说明迁移完成，则向前推进 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span>        <span class="hljs-comment">//(7) 处理当前桶的数据迁移。</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">synchronized</span> (f) &#123;  <span class="hljs-comment">//给头结点加锁</span>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    Node&lt;K,V&gt; ln, hn;                    <span class="hljs-comment">//若hash值大于等于0，则说明是普通链表节点</span>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;                        <span class="hljs-comment">//这里是 1.7 的 CHM 的 rehash 方法和 1.8 HashMap的 resize 方法的结合体。</span>                        <span class="hljs-comment">//会分成两条链表，一条链表和原来的下标相同，另一条链表是原来的下标加数组长度的位置</span>                        <span class="hljs-comment">//然后找到 lastRun 节点，从它到尾结点整体迁移。</span>                        <span class="hljs-comment">//lastRun前边的节点则单个迁移，但是需要注意的是，这里是头插法。</span>                        <span class="hljs-comment">//另外还有一点和1.7不同，1.7 lastRun前边的节点是复制过去的，而这里是直接迁移的，没有复制操作。</span>                        <span class="hljs-comment">//所以，最后会有两条链表，一条链表从 lastRun到尾结点是正序的，而lastRun之前的元素是倒序的，</span>                        <span class="hljs-comment">//另外一条链表，从头结点开始就是倒叙的。看下图。</span>                        Node&lt;K,V&gt; lastRun = f;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;                            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;                            <span class="hljs-keyword">if</span> (b != runBit) &#123;                                runBit = b;                                lastRun = p;                            &#125;                        &#125;                        <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;                            ln = lastRun;                            hn = <span class="hljs-literal">null</span>;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            hn = lastRun;                            ln = <span class="hljs-literal">null</span>;                        &#125;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;                            <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;                            <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)                                ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);                            <span class="hljs-keyword">else</span>                                hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);                        &#125;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = <span class="hljs-literal">true</span>;                    &#125;                    <span class="hljs-comment">//树节点</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                        TreeNode&lt;K,V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                        <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;                            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;                            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;                                (h, e.key, e.val, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);                            <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;                                <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-literal">null</span>)                                    lo = p;                                <span class="hljs-keyword">else</span>                                    loTail.next = p;                                loTail = p;                                ++lc;                            &#125;                            <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-literal">null</span>)                                    hi = p;                                <span class="hljs-keyword">else</span>                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            &#125;                        &#125;                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                        (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                        (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = <span class="hljs-literal">true</span>;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h4 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer()"></a>helpTransfer()</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;    Node&lt;K,V&gt;[] nextTab; <span class="hljs-type">int</span> sc;    <span class="hljs-comment">//头结点为 ForwardingNode ，并且新数组已经初始化</span>    <span class="hljs-keyword">if</span> (tab != <span class="hljs-literal">null</span> &amp;&amp; (f <span class="hljs-keyword">instanceof</span> ForwardingNode) &amp;&amp;        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(tab.length);        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;               (sc = sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//若校验标识失败，或者已经扩容完成，或推进下标到头，则退出</span>            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">//当前线程需要帮助迁移，sc值加1</span>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;                transfer(tab, nextTab);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> nextTab;    &#125;    <span class="hljs-keyword">return</span> table;&#125;</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在JDK8中，ConcurrentHashMap几乎全面改写</p><ol><li>Segment的代码虽然还存在，但是已经没有实际效果了，只是为了兼容JDK7</li><li>锁的粒度变得更小了，以前是通过锁Segment，现在移除了segment后变成了直接锁表头，效率变得更高了</li><li>锁的实现也改变了，以前锁segment的使用ReentrantLock并使用cas进行修改，JDK8变成了使用Synchronized 锁表头，由于Synchronized 进行优化后有了锁升级的过程所以效率并不低</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2的学习笔记</title>
    <link href="/2022/06/05/vue/vue2/"/>
    <url>/2022/06/05/vue/vue2/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue原理概述"><a href="#Vue原理概述" class="headerlink" title="Vue原理概述"></a>Vue原理概述</h2><p>当创建一个 Vue 实例时，你可以传入一个<strong>选项对象</strong>。这篇教程主要描述的就是如何使用这些选项来创建你想要的行为。作为参考，你也可以在 <a href="https://v2.cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">API 文档</a>中浏览完整的选项列表。</p><p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的：</p><div class="code-wrapper"><pre><code class="hljs">根实例└─ TodoList   ├─ TodoItem   │  ├─ TodoButtonDelete   │  └─ TodoButtonEdit   └─ TodoListFooter      ├─ TodosButtonClear      └─ TodoListStatistics</code></pre></div><p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><p>当这些数据改变时，视图会进行重渲染。值得注意的是<strong>只有当实例被创建时就已经存在于 <code>data</code> 中的 property 才是响应式的</strong>。也就是说如果你添加一个新的 property，比如：</p><div class="code-wrapper"><pre><code class="hljs vue">vm.b = &#x27;hi&#x27;</code></pre></div><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。</p><h2 id="脚手架结构"><a href="#脚手架结构" class="headerlink" title="脚手架结构"></a>脚手架结构</h2><div class="code-wrapper"><pre><code class="hljs stylus">├── node_modules ├── public│   ├── favicon<span class="hljs-selector-class">.ico</span>: 页签图标│   └── index<span class="hljs-selector-class">.html</span>: 主页面├── <span class="hljs-attribute">src</span>│   ├── assets: 存放静态资源│   │   └── logo<span class="hljs-selector-class">.png</span>│   │── component: 存放组件│   │   └── HelloWorld<span class="hljs-selector-class">.vue</span>│   │── App<span class="hljs-selector-class">.vue</span>: 汇总所有组件│   │── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>: 入口文件├── <span class="hljs-selector-class">.gitignore</span>: git版本管制忽略的配置├── babel<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>: babel的配置文件├── package<span class="hljs-selector-class">.json</span>: 应用包配置文件 ├── README<span class="hljs-selector-class">.md</span>: 应用描述文件├── package-lock.json：包版本控制文件</code></pre></div><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p><img src="/2022/06/05/vue/vue2/lifecycle.png" alt="vue生命周期图示"></p><h1 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h1><p>一个vue实例包含如下如下</p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 使用 v-bind 绑定动态类名，对象式写法 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;className&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 计算属性，函数式写法 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>计算属性: &#123;&#123; computedProp &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;inputValue&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入内容&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 监听 v-on 指定的 DOM 事件 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>点击按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 使用 v-for 循环渲染数据 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 父组件传入的 props --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件传入的 props: &#123;&#123; parentMsg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 父组件传入的属性，对象式写法</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">parentMsg</span>: <span class="hljs-title class_">String</span></span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 定义组件内部的数据</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">inputValue</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;red&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">list</span>: [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>]</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 计算属性，函数式写法</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">computedProp</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>.<span class="hljs-title function_">toUpperCase</span>();</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 监听数据变化并执行相应的操作</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">watch</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">inputValue</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`新的输入值：<span class="hljs-subst">$&#123;newVal&#125;</span>，旧的输入值：<span class="hljs-subst">$&#123;oldVal&#125;</span>`</span>);</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 定义组件中可复用的方法</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;按钮被点击了！&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 在组件实例被创建时执行回调函数</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;created&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 在组件挂载后执行回调函数</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 可以使用该钩子来修改数据或者进行一些异步操作</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 当数据更新时被调用，可以在此处执行一些操作</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 当组件销毁时被调用</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;destroyed&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><h2 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul><li><p>描述：在组件内部定义数据。</p></li><li><p>类型：Object | Function</p></li><li><p>用法：可以直接在 data 中定义一个对象或者函数。如果是函数，在调用时会返回一个对象，这样可以避免多个实例共享相同的数据。</p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">数据</a></p></li><li><p><strong>data的函数式与对象式</strong></p><p>  在Vue组件中，<strong>当你将 <code>data</code> 定义成一个对象时，这个数据对象在组件中的所有实例之间共享</strong>。这样，在多个实例之间使用相同的数据对象将会出现问题，因为所有实例都将引用相同的数据对象，这意味着如果其中一个实例改变了数据对象中的某个属性，那么它会影响其他所有实例。</p><p>  为了解决这个问题，你需要<strong>将 <code>data</code> 选项定义为一个返回数据对象的函数。这样每个实例都会调用该函数以获取其自己的数据副本</strong>，从而避免了多个实例之间共享相同的数据对象的问题。</p><p>  换句话说，当你将 <code>data</code> 选项定义为一个函数时，Vue在创建新组件实例时，会为每个实例分别调用该函数，以生成与该实例相关联的数据对象。这样就可以确保每个实例都有自己独立的数据副本，互不干扰。</p></li></ul><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ul><li><p>描述：由父组件传递到子组件中的参数。</p></li><li><p>类型：Object | Array</p></li><li><p>用法：在 props 中定义一个对象或者数组，分别表示从父组件接收到的参数名称和类型。</p></li><li><p><strong>使用props 传递参数</strong></p><p>  在Vue中，组件可以通过<code>props</code>来接收外部传递进来的数据。<code>props</code>是一个数组，在其中声明需要从父组件接收的属性。</p><p>  使用<code>props</code>可以将父组件的数据传递给子组件，实现了组件之间的数据交流。同时，通过在子组件设置<code>props</code>的类型、默认值等参数，可以对传入的数据进行校验和处理，确保程序正常运行。</p><p>  原理上，当父组件向子组件传递<code>prop</code>时，Vue会将这些属性包装为响应式对象，并将其注入到子组件实例中。在子组件中，可以像使用本地数据一样使用这些<code>props</code>，并且当父组件的数据发生变化时，这些变化也会反映到子组件中。</p><p>  需要注意的是，**由于Vue的单向数据流特性，子组件不能直接修改从父组件传递下来的<code>prop</code>**，否则会引起警告。如果需要在子组件中修改这些数据，可以通过在子组件中定义一个局部变量，并将<code>prop</code>的值复制给它来实现。</p></li></ul><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul><li>描述：根据依赖的数据动态生成新的属性值。通常用于依赖现有数据计算生成一个更复杂的数据。详细看<a href="https://v2.cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">计算属性</a></li><li>类型：Object</li><li>用法：在 computed 中定义一个对象，对象的 key 表示计算属性的名称，value 是一个函数，其返回值即为该计算属性的值。</li></ul><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul><li>描述：定义组件中可复用的方法。</li><li>类型：Object</li><li>用法：在 methods 中定义一个对象，其中每个属性名表示一个方法名，属性值是对应的函数。</li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul><li>描述：监听某个数据变化并执行相应的操作。详见<a href="https://v2.cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8">监听器</a></li><li>类型：Object</li><li>用法：在 watch 中定义一个对象，其中每个属性名表示需要监听的数据名称，属性值是一个函数，当数据变化时会自动调用该函数。</li></ul><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h3><ul><li>描述：用于触发父组件事件。</li><li>类型：Function</li><li>用法：在子组件中使用 <code>$emit</code> 方法，并传递参数来触发父组件中的指定事件。</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//假设我们有一个父组件 Parent 和一个子组件 Child，现在我们需要在子组件中触发一个事件，并将数据传递给父组件进行处理。此时我们可以在子组件中使用 $emit 方法来实现：</span><span class="hljs-comment">// 子组件 Child</span><span class="hljs-attr">methods</span>: &#123;  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;child-click&#x27;</span>, <span class="hljs-string">&#x27;hello world&#x27;</span>)  &#125;&#125;<span class="hljs-comment">// 父组件 Parent</span>&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> @<span class="hljs-attr">child-click</span>=<span class="hljs-string">&quot;handleChildClick&quot;</span> /&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">handleChildClick</span>(<span class="hljs-params">data</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// 输出：&#x27;hello world&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><h3 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h3><ul><li>描述：用于向响应式对象添加新属性，使它能够响应数据变化。</li><li>类型：Function</li><li>用法：调用 <code>$set</code> 方法，传递要添加属性的对象及属性名和属性值。</li></ul><div class="code-wrapper"><pre><code class="hljs vue">&lt;!--在 Vue.js 中，当我们使用对象或数组来更新组件数据时，Vue.js 会跟踪这些对象或数组的变化，并且自动更新组件的视图。但是，如果在对象或数组中添加新属性或元素时，Vue.js 并不会触发视图更新，因为 Vue.js 无法检测到这种直接添加的变化。这时候，就可以使用 $set 方法来告诉 Vue.js 改变了对象或数组，并触发视图更新。--&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; user.name &#125;&#125; is &#123;&#123; user.age &#125;&#125; years old.&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      user: &#123;        name: &#x27;Tom&#x27;,        age: 25      &#125;    &#125;  &#125;,  methods: &#123;    updateName() &#123;      // 直接修改对象属性，Vue.js 无法检测到变化      this.user.name = &#x27;Jerry&#x27;            // 使用 $set 方法通知 Vue.js 对象发生了变化，并触发视图更新      this.$set(this.user, &#x27;name&#x27;, &#x27;Jerry&#x27;)    &#125;,    addHobby() &#123;      // 直接添加数组元素，Vue.js 无法检测到变化      this.user.hobbies.push(&#x27;reading&#x27;)            // 使用 $set 方法通知 Vue.js 数组发生了变化，并触发视图更新      this.$set(this.user.hobbies, 1, &#x27;swimming&#x27;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;!--在上面的例子中，当点击按钮时，分别调用 updateName 和 addHobby 方法，在 updateName 方法中，直接修改了 user 对象的 name 属性，此时 Vue.js 无法检测到变化，需要使用 $set 方法通知 Vue.js 发生了变化；在 addHobby 方法中，直接向 user.hobbies 数组中添加元素，也需要使用 $set 方法通知 Vue.js 发生了变化。总之，使用 $set 方法可以让 Vue.js 能够检测到对象和数组的变化，并触发视图的更新。--&gt;</code></pre></div><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h3><ul><li>描述：在 DOM 更新完成后执行回调函数。</li><li>类型：Function</li><li>用法：在需要等待 DOM 更新后再做一些操作的情况下，可以使用 <code>$nextTick</code> 方法，传递一个回调函数，在回调函数中进行相关操作。</li></ul><div class="code-wrapper"><pre><code class="hljs vue">&lt;!--$nextTick 是 Vue.js 提供的一个方法，用于在 DOM 更新之后执行回调函数。当你修改了数据并且想要等待 Vue.js 重新渲染 DOM 并完成相关的更新之后再执行一些操作时，可以使用 $nextTick。在 Vue.js 内部，当数据变化时，它并不会立即更新 DOM，而是异步执行更新，这样可以避免频繁的 DOM 操作导致页面性能降低。因此，如果需要在 DOM 更新后进行一些操作，就需要等待 Vue.js 更新完成。这时候就可以使用 $nextTick 来实现。--&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#x27;Hello, world!&#x27;    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      this.message = &#x27;Updated message&#x27;      this.$nextTick(() =&gt; &#123;        // 在 DOM 更新后进行一些操作        console.log(&#x27;DOM updated&#x27;)      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;!--在上面的例子中，当点击按钮时，handleClick 方法被调用，将 message 的值改为 &#x27;Updated message&#x27;，然后在 $nextTick 回调函数中输出 &#x27;DOM updated&#x27;，这表示在 DOM 更新后才执行了该操作。--&gt;</code></pre></div><h2 id="常见钩子"><a href="#常见钩子" class="headerlink" title="常见钩子"></a>常见钩子</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ul><li>描述：在实例初始化之后，数据观测 (data observer) 和事件配置之前被调用。</li><li>类型：Function</li><li>用法：在组件中定义 <code>beforeCreate</code> 钩子函数，在此钩子函数中可以执行一些初始化工作。</li></ul><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><ul><li>描述：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前尚不可用。</li><li>类型：Function</li><li>用法：在组件中定义 <code>created</code> 钩子函数，在此钩子函数中可以进一步处理数据或初始化组件。</li></ul><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul><li>描述：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>类型：Function</li><li>用法：在组件中定义 <code>beforeMount</code> 钩子函数，在此钩子函数中可以进一步处理数据或准备渲染组件。</li></ul><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul><li>描述：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。此时实例的数据和 DOM 已经被渲染完毕。</li><li>类型：Function</li><li>用法：在组件中定义 <code>mounted</code> 钩子函数，在此钩子函数中可以操作 DOM 或者初始化其他插件。</li></ul><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>描述：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中修改数据或者进行一些异步操作。</p><p>类型：Function</p><p>用法：在组件中定义 <code>beforeUpdate</code> 钩子函数，在此钩子函数中可以执行一些操作。</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul><li>描述：数据更新后调用，发生在实例更新之后，调用时组件 DOM 已经更新。要注意的是，这里不能进行数据修改操作，否则会导致死循环。</li><li>类型：Function</li><li>用法：在组件中定义 <code>updated</code> 钩子函数，在此钩子函数中可以处理 DOM 依赖的操作。</li></ul><h1 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h1><h2 id="v-model双向绑定"><a href="#v-model双向绑定" class="headerlink" title="v-model双向绑定"></a>v-model双向绑定</h2><p>双向绑定，input中改变了，就会改变data中的model，进而改变<p>中</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;div id=&quot;app-6&quot;&gt;  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;    &lt;!--可以使用v-model.lazy进行懒加载--&gt;  &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-6&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span>  &#125;&#125;)</code></pre></div><p><img src="/2022/06/05/vue/vue2/image-20230313200244612.png" alt="image-20230313200244612"></p><h2 id="v-bind-绑定"><a href="#v-bind-绑定" class="headerlink" title="v-bind 绑定"></a>v-bind 绑定</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-2&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>    鼠标悬停几秒钟查看此处动态绑定的提示信息！  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-2&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;页面加载于 &#x27;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>()  &#125;&#125;)</code></pre></div><p>效果如图</p><p><img src="/2022/06/05/vue/vue2/image-20230313194815480.png" alt="image-20230313194815480"></p><h2 id="v-if-条件"><a href="#v-if-条件" class="headerlink" title="v-if 条件"></a>v-if 条件</h2><p><a href="https://v2.cn.vuejs.org/v2/guide/conditional.html">详见条件</a></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-3&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-3&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">seen</span>: <span class="hljs-literal">true</span>  &#125;&#125;)</code></pre></div><p>结果，现在你看见我了，成功显示出来</p><p>如果将seen设为false，则不会显示出来</p><h2 id="v-for-循环"><a href="#v-for-循环" class="headerlink" title="v-for 循环"></a>v-for 循环</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-4&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span>      &#123;&#123; todo.text &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-4&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">todos</span>: [      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 JavaScript&#x27;</span> &#125;,      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 Vue&#x27;</span> &#125;,      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;整个牛项目&#x27;</span> &#125;    ]  &#125;&#125;)</code></pre></div><p>结果是循环输出来了</p><p><img src="/2022/06/05/vue/vue2/image-20230313195409041.png" alt="image-20230313195409041"></p><h2 id="v-on-事件监听"><a href="#v-on-事件监听" class="headerlink" title="v-on 事件监听"></a>v-on 事件监听</h2><p>可以与监听事件搭配，触发方法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-5&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-5&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue.js!&#x27;</span>  &#125;,  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)    &#125;  &#125;&#125;)</code></pre></div><p>结果</p><p><img src="/2022/06/05/vue/vue2/image-20230313195545539.png" alt="image-20230313195545539"></p><p>点击一下</p><p><img src="/2022/06/05/vue/vue2/image-20230313195603964.png" alt="image-20230313195603964"></p><p>更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，编写的代码只需要关注逻辑层面即可。</p><h2 id="v-slot-插槽"><a href="#v-slot-插槽" class="headerlink" title="v-slot 插槽"></a>v-slot 插槽</h2><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- 在子组件中定义一个 Slot --&gt;&lt;slot name=&quot;header&quot;&gt;    &lt;!-- 如果没有提供内容，则会显示这里的默认内容 --&gt;    &lt;h1&gt;Default Header&lt;/h1&gt;&lt;/slot&gt;&lt;!-- 在父组件中使用这个 Slot --&gt;&lt;template&gt;&lt;my-component&gt;        &lt;!-- 使用 `v-slot` 来指定要填充哪个 Slot --&gt;        &lt;template v-slot:header&gt;            &lt;h1&gt;Custom Header&lt;/h1&gt;        &lt;/template&gt;&lt;/my-component&gt;&lt;/template&gt;</code></pre></div><p>在这个例子中，子组件 <code>my-component</code> 定义了一个名为 <code>header</code> 的 Slot，并且在其中提供了一个默认的 <code>&lt;h1&gt;</code> 标题，如果父组件没有传入任何内容，就会使用这个默认内容。</p><p>父组件中使用了 <code>v-slot</code> 指令来填充 <code>header</code> Slot，将一个自定义的 <code>&lt;h1&gt;</code> 标题插入到子组件的 <code>header</code> Slot 中。这样，渲染出来的结果就是 <code>&lt;my-component&gt;</code> 组件内部的 <code>header</code> Slot 被替换成了父组件传入的内容。</p><p>总之，通过使用 Slot，我们可以让组件更加灵活和可重用，因为它们允许父组件动态地控制组件的输出内容。</p><h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>组件化，一个页面可以由多个组件构成，一个组件又可以由多个组件构成，为了复用组件</p><p><img src="/2022/06/05/vue/vue2/components.png"></p><p>组件一般放在components包下</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>这里定义了一个Student组件</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名：&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生年龄：&#123;&#123;age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Student&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">                <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,</span><span class="language-javascript">                <span class="hljs-attr">age</span>:<span class="hljs-number">18</span></span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>在另一个Info.vue文件中引用它</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//引入组件</span></span><span class="language-javascript">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Student.vue&quot;</span>;</span><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">            <span class="hljs-title class_">Student</span>,</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">    &#125;;  </span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>于是可以在Info.vue中看见相关信息了</p><h2 id="父作用域和子作用域间通讯"><a href="#父作用域和子作用域间通讯" class="headerlink" title="父作用域和子作用域间通讯"></a>父作用域和子作用域间通讯</h2><h3 id="prop-传递数据"><a href="#prop-传递数据" class="headerlink" title="prop 传递数据"></a>prop 传递数据</h3><p>Student.vue</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;todo.text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Student&quot;</span>,</span><span class="language-javascript">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;todo&#x27;</span>] </span><span class="language-javascript">&#125;;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>App.vue</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Student</span></span><span class="hljs-tag">      <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in groceryList&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">v-bind:todo</span>=<span class="hljs-string">&quot;item&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span></span><span class="hljs-tag">    &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Student.vue&quot;</span>;</span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title class_">Student</span>,</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">groceryList</span>: [</span><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;张三&#x27;</span> &#125;,</span><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;李四&#x27;</span> &#125;,</span><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;王五&#x27;</span> &#125;</span><span class="language-javascript">      ]</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">&#125;;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>这里使用props向子组件传递数据，props相当于子组件的属性，父组件，可以通过v-bind绑定</p><h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p>详见上述</p><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>Vue动态组件是指可以在运行时根据条件或用户交互动态切换不同的组件。使用动态组件可以让应用程序更灵活，具有更好的可扩展性和可维护性。</p><p>Vue中可以通过<code>&lt;component&gt;</code>标签来实现动态组件。<code>&lt;component&gt;</code>标签有一个特殊的属性<code>is</code>，它用来指定当前渲染的组件类型。当<code>is</code>属性发生变化时，<code>&lt;component&gt;</code>标签会自动重新渲染对应的组件。</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;toggleComponent&quot;&gt;Toggle Component&lt;/button&gt;    &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ComponentA from &#x27;./components/ComponentA.vue&#x27;import ComponentB from &#x27;./components/ComponentB.vue&#x27;export default &#123;  data() &#123;    return &#123;      currentComponent: &#x27;ComponentA&#x27;    &#125;  &#125;,  methods: &#123;    toggleComponent() &#123;      this.currentComponent = this.currentComponent === &#x27;ComponentA&#x27; ? &#x27;ComponentB&#x27; : &#x27;ComponentA&#x27;    &#125;  &#125;,  components: &#123;    ComponentA,    ComponentB  &#125;&#125;&lt;/script&gt;</code></pre></div><p>在这个示例中，我们定义了两个组件<code>ComponentA</code>和<code>ComponentB</code>，并将它们注册为本地组件。然后在父组件中，我们使用<code>&lt;component&gt;</code>标签来动态渲染当前选中的组件。当点击按钮时，我们将<code>currentComponent</code>属性切换为另一个组件名称，从而触发<code>&lt;component&gt;</code>标签的重新渲染。</p><p>值得注意的是，为了能够正确地渲染动态组件，每个组件都需要有一个唯一的<code>key</code>属性。<code>key</code>属性可以帮助Vue识别每个组件的唯一性，从而避免出现莫名其妙的渲染问题。</p><p>总之，Vue动态组件是非常有用和强大的特性，可以帮助我们构建更加灵活和可扩展的应用程序。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p>Vue 路由支持两种模式：hash 模式和 history 模式。默认情况下，Vue 路由使用 hash 模式。</p><h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><p>在 hash 模式下，URL 中会带有一个 <code>#</code> 号和后面的路径信息。例如：<code>http://localhost/#/about</code>。浏览器地址栏中的 <code>#</code> 号以及它后面的内容并不会被发送到服务器，而是由浏览器端解析处理。这样做的好处是，即使用户在页面中进行了操作导致 URL 发生变化，也不会向服务器发送请求，从而避免了刷新页面带来的延迟问题。</p><h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>在 history 模式下，URL 中不再带有 <code>#</code> 号，而是直接显示路径信息。例如：<code>http://localhost/about</code>。这种模式需要服务端对所有可能的路径都进行设置，否则访问不存在的路径时就会报错。在使用 history 模式时，如果需要在本地开发环境中调试，需要配置 web 服务器支持单页应用的路由。如：配置 nginx、Apache 或使用 express 等 Node.js 服务器。</p><p>可以通过在创建 VueRouter 实例时传递 <code>mode</code> 参数来指定路由模式。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,  <span class="hljs-attr">routes</span>: [...]&#125;)</code></pre></div><h2 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h2><p>为了使用Vue Router，我们需要先安装它：</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> vue-router</code></pre></div><p>然后，在我们的Vue.js应用程序中，我们需要创建Vue Router实例并将其导入我们的Vue实例中。我们可以使用Vue.use()方法来注册Vue Router插件，并将router对象传递给我们的Vue实例。</p><p>下面是一个基本的示例：</p><ol><li><p>在src下新建router包，其中新建路由文件index.js</p> <div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 该文件专门用于创建整个应用的路由器</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-comment">//引入组件</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Student&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">School</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/School&#x27;</span>;<span class="hljs-comment">//创建并暴露一个路由器</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;    <span class="hljs-attr">routes</span>: [        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/student&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Student</span>        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/school&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-title class_">School</span>        &#125;    ]&#125;)</code></pre></div></li><li><p>在mian.js中引用路由</p> <div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-comment">//引入vue router</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><span class="hljs-comment">//关闭Vue的生产提示</span><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><span class="hljs-comment">//使用vue-router</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<span class="hljs-comment">//创建vm</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),  router : router,&#125;)</code></pre></div></li><li><p>新建两个组件School、Student</p></li><li><p>在App.vue中引用</p> <div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;&lt;div&gt;  &lt;div class=&quot;row&quot;&gt;    &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;      &lt;div class=&quot;list-group&quot;&gt;        &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/student&quot;&gt;Student&lt;/router-link&gt;        &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/school&quot;&gt;School&lt;/router-link&gt;      &lt;/div&gt;    &lt;/div&gt;      &lt;div class=&quot;col-xs-6&quot;&gt;        &lt;div class=&quot;panel&quot;&gt;          &lt;div class=&quot;panel-body&quot;&gt;            &lt;!-- 指定组件的呈现位置 --&gt;            &lt;router-view&gt;&lt;/router-view&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;App&quot;,&#125;;  &lt;/script&gt;</code></pre></div></li></ol><p>在这个例子中，我们首先从Vue包中导入Vue和VueRouter模块。然后，我们使用Vue.use()方法来注册Vue Router插件。接着，我们定义了我们的路由数组，并在每个路由上指定了路径、名称和组件。最后，我们创建一个新的Vue Router实例，并将路由数组传递给它。我们将该实例导出，以便我们可以在我们的应用程序中使用它。</p><p>在我们的Vue组件中，我们可以通过router属性来访问VueRouter实例。例如，我们可以使用router.push()方法来在组件之间进行导航：</p><div class="code-wrapper"><pre><code class="hljs arcade">this.<span class="hljs-symbol">$router</span>.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;/about&#x27;</span>)</code></pre></div><p>这将会将URL更改为“&#x2F;about”，并加载关联的组件。</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>动态路由是指路由路径中包含参数的情况，例如 <code>/user/:id</code>。其中，<code>:id</code> 就是参数名称。当用户访问 <code>/user/123</code> 这样的路径时，实际上会进入到 <code>User</code> 组件，并且该组件内可以通过 <code>$route.params.id</code> 获取到参数的值。</p><p>我们可以在路由表中使用 <code>:</code> 来定义动态参数，例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;]</code></pre></div><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>嵌套路由是指在一个路由下还有其它子路由的情况，例如一个电商网站的订单页面，可能需要进一步展示订单详情、发货信息等子页面。在 Vue 路由中，可以通过 <code>children</code> 属性来定义嵌套路由。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/order&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Order</span>,    <span class="hljs-attr">children</span>: [      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;detail&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">OrderDetail</span> &#125;,      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;shipping&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">ShippingInfo</span> &#125;    ]  &#125;]</code></pre></div><p>在上述路由表中，<code>/order/detail</code> 和 <code>/order/shipping</code> 都是 <code>Order</code> 组件的子组件。因此，在 <code>Order</code> 组件中可以使用 <code>&lt;router-view&gt;</code> 标签来渲染子组件。</p><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>Vue Router提供了导航守卫，这些守卫允许我们在组件之间导航时执行操作。例如，我们可以使用“beforeEach”导航守卫来检查用户是否已经登录，如果没有，则将其重定向到登录页面：</p><div class="code-wrapper"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>)  <span class="hljs-comment">// 如果用户未登录且访问需要权限的页面，则重定向到登录页面</span>  <span class="hljs-keyword">if</span> (!token &amp;&amp; to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span>) &#123;     <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">next</span>()  &#125;&#125;)</code></pre></div><p>在这个例子中，我们检查每个要访问的路由记录上是否有requiresAuth元数据标记。如果有，则检查用户是否已经登录。如果未登录，则将用户重定向到登录页面，并在queryString中存储原始请求路径。</p><p>导航守卫是指在路由跳转前或跳转后执行的一些额外逻辑。Vue 路由提供了三个全局导航守卫：<code>beforeEach</code>、<code>beforeResolve</code> 和 <code>afterEach</code>，以及每个路由组件内部的导航守卫：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code>。</p><ul><li><p><code>beforeEach(to, from, next)</code>：在所有路由跳转前都会执行，可以用来判断用户是否登录等操作。</p></li><li><p><code>beforeResolve(to, from, next)</code>：在所有异步路由组件被解析之后，路由跳转前被调用。</p></li><li><p><code>afterEach(to, from)</code>：在路由跳转完成后被调用，可以用来进行一些异步操作。</p></li><li><p><code>beforeRouteEnter(to, from, next)</code>：在路由进入组件前被调用，可以用来获取数据等操作。</p></li><li><p><code>beforeRouteUpdate(to, from, next)</code>：在同一个路由组件内跳转路</p></li></ul><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>在大型应用程序中，我们可能有数十个甚至数百个组件，这些组件不会全部在应用程序启动时加载。为了提高性能，我们可以使用Vue Router的路由懒加载功能，仅在需要时加载组件代码。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Foo</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)</code></pre></div><p>在这里，我们使用“import()”语法来动态地加载Foo组件。当用户访问该路由时，只有在需要时才会下载和解析组件代码。</p><p>总的来说，Vue Router是一个非常强大和灵活的工具，可以帮助我们构建复杂的单页应用程序和动态路由。</p><h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><h2 id="Props-x2F-Events"><a href="#Props-x2F-Events" class="headerlink" title="Props&#x2F;Events"></a>Props&#x2F;Events</h2><p>父组件通过 props 将数据传递给子组件，子组件通过 $emit 触发事件来通知父组件。这种方式适合父子组件之间的通信。详见上述。</p><h2 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h2><p>在Vue中创建一个空的Vue实例作为总线，在需要通信的组件中分别引入并使用该实例来触发和监听事件，从而实现任意两个组件之间的通信。这种方式适合非父子组件之间的通信。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在Vue中，你可以使用事件总线（Event Bus）来处理组件之间的通信。以下是一个简单的示例代码，演示了如何使用事件总线在两个组件之间通信：</p><ol><li>首先，在Vue应用程序的根组件中创建Event Bus实例，并将其导出给所有子组件使用：</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();</code></pre></div><ol start="2"><li>然后，在需要进行通信的组件中（例如，组件A和组件B），你可以注册自己的事件监听器并发布事件：</li></ol><p>组件A：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-string">&#x27;Hello World!&#x27;</span>);    &#125;  &#125;&#125;</code></pre></div><p>组件B：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received event with data:&#x27;</span>, data);    &#125;);  &#125;&#125;</code></pre></div><p>在上面的示例中，我们首先导入了Event Bus实例，然后将“my-event”事件注册到组件A的单击事件中。当用户单击组件A时，它会通过Event Bus发布一个新的“my-event”事件，并传递字符串“Hello World!”作为数据。</p><p>然后，我们在组件B中注册了一个事件监听器以接收“my-event”事件。当Event Bus接收到新事件时，它将调用回调函数并传递事件数据。在这种情况下，我们仅将数据打印到控制台上。</p><p>请注意，由于Event Bus是一个全局Vue实例，所以你可以在应用程序的任何组件中使用它。这使得它成为一种非常方便的工具来处理不同组件之间的通信。</p><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><ol><li>传递复杂数据：如果你需要在组件之间传递复杂的数据结构，例如对象或数组，你可以将它们作为单个事件参数传递。在接收事件的组件中，你可以使用解构赋值语法来提取所需的数据。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 发布事件</span><span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;my-event&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;);<span class="hljs-comment">// 接收事件</span><span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123; name, age &#125; = data;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received event with name <span class="hljs-subst">$&#123;name&#125;</span> and age <span class="hljs-subst">$&#123;age&#125;</span>`</span>);&#125;);</code></pre></div><ol start="2"><li>使用别名：如果你不想在每个.vue文件中都导入Event Bus实例，你可以将其定义为全局Vue插件，并使用别名来访问它。这样做可以帮助你更好地组织和管理你的代码。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义插件并设置别名</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(&#123;  <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) &#123;    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();  &#125;&#125;, <span class="hljs-string">&#x27;$bus&#x27;</span>);<span class="hljs-comment">// 在组件中使用别名</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received my-event&#x27;</span>);    &#125;);  &#125;&#125;</code></pre></div><ol start="3"><li>取消事件监听器：如果你需要在某个时刻取消已注册的事件监听器，你可以使用“$off”方法。你可以传递事件类型和回调函数来指定要取消的事件监听器。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 注册事件监听器</span><span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received my-event&#x27;</span>);&#125;);<span class="hljs-comment">// 取消事件监听器</span><span class="hljs-title class_">EventBus</span>.$off(<span class="hljs-string">&#x27;my-event&#x27;</span>);</code></pre></div><ol start="4"><li>全局事件钩子：如果你需要在整个应用程序中监听某些事件（例如路由切换、用户登录等），你可以使用Vue的全局事件钩子来完成。你可以在Vue实例上注册全局事件钩子，以便在特定生命周期钩子函数被调用时自动执行特定操作。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 注册全局事件钩子</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;component-mounted&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">name</span>);  &#125;&#125;);<span class="hljs-comment">// 接收事件</span><span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;component-mounted&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">componentName</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Component <span class="hljs-subst">$&#123;componentName&#125;</span> has been mounted`</span>);&#125;);</code></pre></div><p>总的来说，Vue的事件总线是一个非常强大的工具，可以帮助你更好地管理和组织组件之间的通信，并提高应用程序的可维护性和可扩展性。</p><h3 id="使用命名空间划分store"><a href="#使用命名空间划分store" class="headerlink" title="使用命名空间划分store"></a>使用命名空间划分store</h3><p>在Vue中，每个应用只能有一个唯一的Vuex.Store实例。这是因为Vuex.Store是全局的状态管理器，负责管理整个应用的状态数据。如果创建多个Vuex.Store实例，会导致状态数据的混乱和不可预测行为。</p><p>如果需要隔离使用多个状态管理器，可以考虑使用命名空间（namespace）来划分模块。在Vuex中，一个Vuex.Store实例包含多个module，每个module都可以拥有自己的state、mutations、actions和getters，并且还可以嵌套其他module。通过给每个module设置唯一的命名空间，就可以实现状态数据的隔离。</p><p>例如，可以创建两个module，分别命名为”moduleA”和”moduleB”，并且为它们设置不同的命名空间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">moduleA</span>: &#123;      <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">state</span>: &#123; ... &#125;,      <span class="hljs-attr">mutations</span>: &#123; ... &#125;,      <span class="hljs-attr">actions</span>: &#123; ... &#125;,      <span class="hljs-attr">getters</span>: &#123; ... &#125;    &#125;,    <span class="hljs-attr">moduleB</span>: &#123;      <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">state</span>: &#123; ... &#125;,      <span class="hljs-attr">mutations</span>: &#123; ... &#125;,      <span class="hljs-attr">actions</span>: &#123; ... &#125;,      <span class="hljs-attr">getters</span>: &#123; ... &#125;    &#125;  &#125;&#125;)</code></pre></div><p>然后，在组件中访问moduleA和moduleB的状态或者执行它们的操作时，需要加上命名空间前缀：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">moduleA</span>.<span class="hljs-property">xxx</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;moduleB/actionName&#x27;</span>, payload)</code></pre></div><p>这样就可以实现多个状态管理器的隔离使用。</p><h3 id="多个Store，模块化使用"><a href="#多个Store，模块化使用" class="headerlink" title="多个Store，模块化使用"></a>多个Store，模块化使用</h3><p>在 Vue 中是可以有多个 Vuex.Store 的，每个 Store 可以独立维护自己的状态。通常情况下一个应用只需要一个 Store 就足够了，但在一些复杂的场景中可能需要使用多个 Store 来分别管理不同的状态。</p><p>以下是一个示例：</p><p>假设我们有两个页面：Page A 和 Page B，它们分别位于 src&#x2F;pages&#x2F;PageA.vue 和 src&#x2F;pages&#x2F;PageB.vue 文件中。</p><p>我们可以为每个页面创建单独的 Store，并将其存储在不同的 js 文件中。例如，PageA 需要一个名为 pageAStore 的 Store，而 PageB 需要一个名为 pageBStore 的 Store。</p><p>在 src&#x2F;store 目录中新建两个文件：</p><p>pageAStore.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">count</span>++    &#125;  &#125;&#125;)</code></pre></div><p>pageBStore.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params">state, payload</span>) &#123;      state.<span class="hljs-property">message</span> = payload    &#125;  &#125;&#125;)</code></pre></div><p>然后在 PageA 和 PageB 中分别导入对应的 Store：</p><p>PageA.vue</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Page A&lt;/h2&gt;    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pageAStore from &#x27;@/store/pageAStore&#x27;export default &#123;  data() &#123;    return &#123;      store: pageAStore    &#125;  &#125;,  computed: &#123;    count() &#123;      return this.$store.state.count    &#125;  &#125;,  methods: &#123;    increment() &#123;      this.store.commit(&#x27;increment&#x27;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>PageB.vue</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Page B&lt;/h2&gt;    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;    &lt;input v-model=&quot;newMessage&quot;&gt;    &lt;button @click=&quot;updateMessage&quot;&gt;Update Message&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pageBStore from &#x27;@/store/pageBStore&#x27;export default &#123;  data() &#123;    return &#123;      store: pageBStore,      newMessage: &#x27;&#x27;    &#125;  &#125;,  computed: &#123;    message() &#123;      return this.$store.state.message    &#125;  &#125;,  methods: &#123;    updateMessage() &#123;      this.store.commit(&#x27;updateMessage&#x27;, this.newMessage)      this.newMessage = &#x27;&#x27;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>注意，在每个页面组件中，我们需要将对应的 Store 对象赋值给组件实例的 data 属性中的 store，这样我们就可以通过 this.store 访问该页面的 Store 实例。</p><p>使用这种方式，我们就可以在不同的页面中使用不同的 Vuex.Store，并且它们互不干扰，从而更好地达到状态管理的目的。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是 Vue.js 的官方状态管理工具，提供了一个集中式存储管理应用的所有组件的状态，通过 mutations 来修改状态，通过 getters 来获取状态，通过 actions 来提交 mutations，从而实现组件之间的共享状态和通信。</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>在使用 Vuex 之前，需要先安装和引入它：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 安装</span>npm install vuex --save<span class="hljs-comment">// 引入</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)</code></pre></div><p>接下来，在创建 Vue 实例之前，需要定义一个 store：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">count</span>++    &#125;  &#125;,  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)      &#125;, <span class="hljs-number">1000</span>)    &#125;  &#125;,  <span class="hljs-attr">getters</span>: &#123;    <span class="hljs-attr">doubleCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>  &#125;&#125;)</code></pre></div><p>上面的代码中，我们先定义了一个 state 对象，其中包含了应用程序的状态数据。然后定义了一个 mutation 函数（increment），它是唯一能够修改 state 的函数，必须是同步函数。还定义了一个 action 函数（incrementAsync）用于异步提交 mutation，这里使用了 ES6 的解构语法。最后定义了一个 getter 函数（doubleCount），它是从 state 获取派生状态的函数。</p><p>最后，在 Vue 实例中，将 store 注入到根组件中即可：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,  store,  <span class="hljs-attr">computed</span>: &#123;    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>    &#125;,    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>    &#125;  &#125;,  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)    &#125;,    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;incrementAsync&#x27;</span>)    &#125;  &#125;&#125;)</code></pre></div><h3 id="进阶使用-1"><a href="#进阶使用-1" class="headerlink" title="进阶使用"></a>进阶使用</h3><p>除了基本使用外，Vuex 还支持模块化、插件等更高级的功能。</p><ol><li>模块化：当应用程序变得非常复杂时，可以将 store 拆分成多个模块，每个模块都有自己的 state、mutation、action、getter 等。这样做有助于提高代码的可维护性和可扩展性。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-attr">state</span>: &#123; ... &#125;,  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;,  <span class="hljs-attr">getters</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> moduleB = &#123;  <span class="hljs-attr">state</span>: &#123; ... &#125;,  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;,  <span class="hljs-attr">getters</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">a</span>: moduleA,    <span class="hljs-attr">b</span>: moduleB  &#125;&#125;)</code></pre></div><ol><li>插件：Vuex 允许开发者编写插件来扩展其功能。插件可以监听 mutation、提交 mutation、替换 mutation 等。例如，可以编写一个插件来实现状态持久化功能，将 state 存储在 localStorage 中。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPlugin</span> = store =&gt; &#123;  <span class="hljs-comment">// 监听 mutation</span>  store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 在 mutation 后将 state 存储到 localStorage 中</span>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))  &#125;)  <span class="hljs-comment">// 替换 mutation</span>  store.<span class="hljs-title function_">replaceMutation</span>(<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">state, payload</span>) =&gt;</span> &#123;    state.<span class="hljs-property">count</span> += payload.<span class="hljs-property">amount</span>  &#125;)&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123; ... &#125;,  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">plugins</span>: [myPlugin]&#125;)</code></pre></div><p>总之，Vuex 是一个功能强大、易于使用的状态管理库，不仅可以帮助我们更好地管理和维护 Vue 应用程序中的共享状态，还支持模块化、插件等高级功能，使应用程序的架构设计更加优雅和灵活。</p><h2 id="Provide-x2F-Inject"><a href="#Provide-x2F-Inject" class="headerlink" title="Provide&#x2F;Inject"></a>Provide&#x2F;Inject</h2><p>父组件通过 provide 提供数据，子组件通过 inject 注入数据。这种方式可以将数据注入到所有后代组件中，而不必在每个组件中显式地传递数据。</p><h2 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h2><p>每个Vue组件都有一个 $refs 属性，该属性可以访问组件实例，并且可以在父组件中直接访问子组件或在子组件中访问父组件，从而实现组件之间的通信。</p><h2 id="parent-x2F-children"><a href="#parent-x2F-children" class="headerlink" title="$parent&#x2F;children"></a>$parent&#x2F;children</h2><p>每个Vue组件实例都有 $parent 和 $children 属性，可以通过这些属性访问父组件和子组件，从而实现组件之间的通信。</p><h1 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h1><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​在vue.config.js中添加如下配置：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>:&#123;  <span class="hljs-attr">proxy</span>:<span class="hljs-string">&quot;http://localhost:5000&quot;</span>&#125;</code></pre></div><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​编写vue.config.js配置具体代理规则：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<span class="hljs-attr">devServer</span>: &#123;      <span class="hljs-attr">proxy</span>: &#123;      <span class="hljs-string">&#x27;/api1&#x27;</span>: &#123;<span class="hljs-comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,<span class="hljs-comment">// 代理目标的基础路径</span>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api1&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;      &#125;,      <span class="hljs-string">&#x27;/api2&#x27;</span>: &#123;<span class="hljs-comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<span class="hljs-comment">// 代理目标的基础路径</span>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api2&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span><span class="hljs-comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span><span class="hljs-comment">   changeOrigin默认值为true</span><span class="hljs-comment">*/</span></code></pre></div><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="使用axios-1"><a href="#使用axios-1" class="headerlink" title="使用axios"></a>使用axios</h2><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,        <span class="hljs-attr">methods</span>:&#123;            <span class="hljs-title function_">getStudents</span>(<span class="hljs-params"></span>)&#123;                axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/students&#x27;</span>)                    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;                    <span class="hljs-comment">// 处理成功情况</span>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);                &#125;)                    .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;                    <span class="hljs-comment">// 处理错误情况</span>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);                &#125;)                    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finial&#x27;</span>);                    <span class="hljs-comment">// 总是会执行</span>                &#125;);            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
