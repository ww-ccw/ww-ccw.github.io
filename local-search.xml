<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Bean注入详解</title>
    <link href="/2022/09/06/spring/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/09/06/spring/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h2><ol><li><p>起步</p> <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//1、读取配置文件</span>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;Application.xml&quot;</span>);        <span class="hljs-comment">//得到bean</span>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;a&quot;</span>, A.class);        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;b&quot;</span>, B.class);    &#125;&#125;</code></pre></div></li><li><p>对象初始化，略过</p></li><li><p>读取并解析XML文件</p> <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(</span><span class="hljs-params">    String[] configLocations, <span class="hljs-type">boolean</span> refresh, <span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span>    <span class="hljs-keyword">throws</span> BeansException &#123;    <span class="hljs-built_in">super</span>(parent);    setConfigLocations(configLocations);    <span class="hljs-keyword">if</span> (refresh) &#123;        <span class="hljs-comment">//3、refresh()读取xml初始化</span>        refresh();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultResourceLoader</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigurableApplicationContext</span> &#123;    <span class="hljs-comment">//4、读取并解析xml</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;            <span class="hljs-comment">//准备上下文</span>            prepareRefresh();            <span class="hljs-comment">// 告诉子类刷新内部 bean 工厂。</span>            <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();            <span class="hljs-comment">// 准备 bean 工厂以在此上下文中使用。</span>            prepareBeanFactory(beanFactory);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 允许在上下文子类中对 bean 工厂进行后处理。</span>                postProcessBeanFactory(beanFactory);                <span class="hljs-comment">// 调用在上下文中注册为 bean 的工厂处理器。</span>                invokeBeanFactoryPostProcessors(beanFactory);                <span class="hljs-comment">// 注册拦截 bean 创建的 bean 处理器。</span>                registerBeanPostProcessors(beanFactory);                <span class="hljs-comment">// 为此上下文初始化消息源。</span>                initMessageSource();                <span class="hljs-comment">// 为此上下文初始化事件多播器。</span>                initApplicationEventMulticaster();                <span class="hljs-comment">// 初始化特定上下文子类中的其他特殊 bean。</span>                onRefresh();                <span class="hljs-comment">// 检查侦听器 bean 并注册它们。</span>                registerListeners();                <span class="hljs-comment">// 实例化所有剩余的（非惰性初始化）单例。</span>                finishBeanFactoryInitialization(beanFactory);<span class="hljs-comment">//  5、初始化beanFactory</span>                <span class="hljs-comment">// 最后一步：发布相应的事件。</span>                finishRefresh();            &#125;            <span class="hljs-keyword">catch</span> (BeansException ex) &#123;                <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;                    logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +                                <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);                &#125;                <span class="hljs-comment">// 销毁已经创建的单例以避免悬空资源。</span>                destroyBeans();                <span class="hljs-comment">// Reset &#x27;active&#x27; flag.重置“活动”标志。</span>                cancelRefresh(ex);                <span class="hljs-comment">// 将异常传播给调用者。</span>                <span class="hljs-keyword">throw</span> ex;            &#125;            <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">// 重置 Spring 核心中常见的自省缓存，</span>                <span class="hljs-comment">// 因为我们可能不再需要单例 bean 的元数据了......</span>                resetCommonCaches();            &#125;        &#125;    &#125;&#125;</code></pre></div></li><li><p>初始化BeanFactory,最后调用方法进行bean的实例化</p> <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//6、初始化BeanFactory，并初始化单例Bean</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;    <span class="hljs-comment">// 为此上下文初始化转换服务。</span>    <span class="hljs-keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;        beanFactory.setConversionService(            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));    &#125;    <span class="hljs-comment">// 如果之前没有注册过任何 bean 后处理器（例如 PropertyPlaceholderConfigurer bean），</span>    <span class="hljs-comment">// 则注册一个默认的嵌入值解析器：此时，主要用于解析注释属性值。</span>    <span class="hljs-keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));    &#125;    <span class="hljs-comment">// 尽早初始化 LoadTimeWeaverAware bean，以便尽早注册它们的转换器。</span>    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;        getBean(weaverAwareName);    &#125;    <span class="hljs-comment">// 停止使用临时 ClassLoader 进行类型匹配。</span>    beanFactory.setTempClassLoader(<span class="hljs-literal">null</span>);    <span class="hljs-comment">// 允许缓存所有 bean 定义元数据，而不是期望进一步的更改。</span>    beanFactory.freezeConfiguration();    <span class="hljs-comment">// 实例化所有剩余的（非惰性初始化）单例。</span>    beanFactory.preInstantiateSingletons();<span class="hljs-comment">//7、beanFactory的实例化已经完成，接下来实例化bean</span>&#125;</code></pre></div></li><li><p>预实例化单例</p> <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;        logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-comment">// 创建一个数组，里面是将要实例化的bean信息</span>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);    <span class="hljs-comment">// 触发所有非惰性单例 bean 的初始化...</span>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;                    <span class="hljs-type">boolean</span> isEagerInit;                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;                        isEagerInit = AccessController.doPrivileged(                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,                            getAccessControlContext());                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());                    &#125;                    <span class="hljs-keyword">if</span> (isEagerInit) &#123;                        getBean(beanName);                    &#125;                &#125;            &#125;            <span class="hljs-keyword">else</span> &#123;                getBean(beanName);<span class="hljs-comment">//8、得到Bean</span>            &#125;        &#125;    &#125;</code></pre></div></li><li><p>使用getBean()实例化对象</p> <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//9、getBean()调用doGetBean()来实际运行</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 返回指定 bean 的一个实例，该实例可以是共享的，也可以是独立的。</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> name 要检索的 bean 的名称</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> requiredType 需要检索的 bean 类型</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> args 使用显式参数创建 bean 实例时使用的参数（仅在创建新实例而不是检索现有实例时应用）</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> typeCheckOnly 是否获取实例进行类型检查，而不是实际使用</span><span class="hljs-comment">*/</span><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><span class="hljs-params">    String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span>    <span class="hljs-keyword">throws</span> BeansException &#123;    <span class="hljs-comment">//检查别名</span>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);    Object bean;    <span class="hljs-comment">// 先去缓存中查询一下是否已经实例化</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;            <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;                logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +                             <span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);            &#125;            <span class="hljs-keyword">else</span> &#123;                logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);            &#125;        &#125;        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 如果我们已经在创建这个 bean 实例则失败 抛出：BeanCurrentlyInCreationException</span>        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);        &#125;        <span class="hljs-comment">// 检查此工厂中是否存在 bean 定义（bean是否有父子包含关系）</span>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;            <span class="hljs-comment">// Not found -&gt; check parent.</span>            <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(                    nameToLookup, requiredType, args, typeCheckOnly);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">// Delegation to parent with explicit args.</span>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span>                <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);            &#125;        &#125;        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;            <span class="hljs-comment">//9、将Bean标记为已创建，接下来就要开始创建了</span>            markBeanAsCreated(beanName);        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建Bean，RootBeanDefinition就是在Bean容器中抽象的Bean</span>            <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);            checkMergedBeanDefinition(mbd, beanName, args);            <span class="hljs-comment">// 保证当前 bean 所依赖的 bean 的初始化。</span>            String[] dependsOn = mbd.getDependsOn();            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//false</span>                <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,                                                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);                    &#125;                    registerDependentBean(dep, beanName);                    <span class="hljs-keyword">try</span> &#123;                        getBean(dep);                    &#125;                    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,                                                        <span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 创建Bean实例</span>            <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<span class="hljs-comment">//判断是否是单例</span>                sharedInstance = getSingleton(beanName, () -&gt; &#123;                    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//-----------------------------重点-------------------------------------------------------------</span>                        <span class="hljs-comment">//10、创建Bean，详见注2</span>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);                    &#125;                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;                        <span class="hljs-comment">//从单例缓存中显式删除实例：它可能已被创建放在了eagerly缓存中，以允许循环引用解析。还要删除任何接收到对 bean 的临时引用的 bean。</span>                        destroySingleton(beanName);                        <span class="hljs-keyword">throw</span> ex;                    &#125;                &#125;);                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;                <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span>                <span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;                <span class="hljs-keyword">try</span> &#123;                    beforePrototypeCreation(beanName);                    prototypeInstance = createBean(beanName, mbd, args);                &#125;                <span class="hljs-keyword">finally</span> &#123;                    afterPrototypeCreation(beanName);                &#125;                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();                <span class="hljs-keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);                &#125;                <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);                <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);                &#125;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, () -&gt; &#123;                        beforePrototypeCreation(beanName);                        <span class="hljs-keyword">try</span> &#123;                            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);                        &#125;                        <span class="hljs-keyword">finally</span> &#123;                            afterPrototypeCreation(beanName);                        &#125;                    &#125;);                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);                &#125;                <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName,                                                    <span class="hljs-string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +                                                    <span class="hljs-string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,                                                    ex);                &#125;            &#125;        &#125;        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;            cleanupAfterBeanCreationFailure(beanName);            <span class="hljs-keyword">throw</span> ex;        &#125;    &#125;    <span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span>    <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">T</span> <span class="hljs-variable">convertedBean</span> <span class="hljs-operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);            <span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());            &#125;            <span class="hljs-keyword">return</span> convertedBean;        &#125;        <span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;                logger.trace(<span class="hljs-string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; to required type &#x27;&quot;</span> +                             ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());        &#125;    &#125;    <span class="hljs-keyword">return</span> (T) bean;&#125;</code></pre></div></li><li><p>6</p></li><li><p>7</p></li></ol><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><h4 id="注1："><a href="#注1：" class="headerlink" title="注1："></a>注1：</h4><p>这段代码是为了去一级缓存中查询一下Bean对象是否在一级缓存中，或者是否已经创建但未完成注入。&#x3D;&#x3D;&gt;结果是null</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@Nullable</span><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName)</span> &#123;    <span class="hljs-keyword">return</span> getSingleton(beanName, <span class="hljs-literal">true</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 返回在给定名称下注册的（原始）单例对象。</span><span class="hljs-comment">* 检查已经实例化的单例，还允许对当前创建的单例进行早期引用（解决循环引用）。</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Nullable</span><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;    <span class="hljs-comment">// 快速检查没有完整实例化的现有实例</span>    <span class="hljs-comment">// 首先从singletonObjects（一级缓存）中查找</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);    <span class="hljs-comment">//如果已经实例化但未完成注入则继续。</span>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<span class="hljs-comment">//false</span>        <span class="hljs-comment">// 如果一级缓存中没有再去二级缓存中查找</span>        singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;                <span class="hljs-comment">// 在完整的单例锁中一致地创建早期引用</span>                singletonObject = <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;                    singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);                    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;                        ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);                        <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;                            singletonObject = singletonFactory.getObject();                            <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);                            <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> singletonObject;&#125;</code></pre></div><h4 id="注2："><a href="#注2：" class="headerlink" title="注2："></a>注2：</h4><p>此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span>    <span class="hljs-keyword">throws</span> BeanCreationException &#123;    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;        logger.trace(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);    &#125;    <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbdToUse</span> <span class="hljs-operator">=</span> mbd;    <span class="hljs-comment">//解析Ben：确保此时实际解析了 bean 类，并克隆 bean 定义以防动态解析的 Class 无法存储在共享的合并 bean 定义中。</span>    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;        mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(mbd);        mbdToUse.setBeanClass(resolvedClass);    &#125;    <span class="hljs-comment">// Prepare method overrides.</span>    <span class="hljs-keyword">try</span> &#123;        mbdToUse.prepareMethodOverrides();    &#125;    <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),                                               beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, ex);    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);        <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> bean;        &#125;    &#125;    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,                                        <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);    &#125;    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//---------------------------------------重点-------------------------------------------------------</span>        <span class="hljs-comment">//创建Ben</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;            logger.trace(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> beanInstance;    &#125;    <span class="hljs-keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;        <span class="hljs-comment">// A previously detected exception with proper bean creation context already,</span>        <span class="hljs-comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span>        <span class="hljs-keyword">throw</span> ex;    &#125;    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(            mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, ex);    &#125;&#125;<span class="hljs-comment">//实际创建指定Bean</span><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><span class="hljs-keyword">throws</span> BeanCreationException &#123;<span class="hljs-comment">// Instantiate the bean.</span><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);&#125;<span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//-------------------重点-------------------------------------------------------------------------</span>            <span class="hljs-comment">//创建Bean实例</span>instanceWrapper = createBeanInstance(beanName, mbd, args);&#125;<span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;mbd.resolvedTargetType = beanType;&#125;<span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<span class="hljs-keyword">try</span> &#123;applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<span class="hljs-string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);&#125;mbd.postProcessed = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span><span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;isSingletonCurrentlyInCreation(beanName));<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);&#125;addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));&#125;<span class="hljs-comment">// Initialize the bean instance.</span><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<span class="hljs-keyword">try</span> &#123;populateBean(beanName, mbd, instanceWrapper);exposedObject = initializeBean(beanName, exposedObject, mbd);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;<span class="hljs-keyword">throw</span> (BeanCreationException) ex;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Initialization of bean failed&quot;</span>, ex);&#125;&#125;<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (exposedObject == bean) &#123;exposedObject = earlySingletonReference;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;String[] dependentBeans = getDependentBeans(beanName);Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);<span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;actualDependentBeans.add(dependentBean);&#125;&#125;<span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName,<span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<span class="hljs-string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);&#125;&#125;&#125;&#125;<span class="hljs-comment">// Register bean as disposable.</span><span class="hljs-keyword">try</span> &#123;registerDisposableBeanIfNecessary(beanName, bean, mbd);&#125;<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);&#125;<span class="hljs-keyword">return</span> exposedObject;&#125;<span class="hljs-comment">//选择适当策略为指定Bean生成一个实例</span><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> &#123;<span class="hljs-comment">// 确保此时实际解析了 bean 类。</span>Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);<span class="hljs-keyword">if</span> (beanClass != <span class="hljs-literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<span class="hljs-string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());&#125;Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();<span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);&#125;<span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);&#125;<span class="hljs-comment">// Shortcut when re-creating the same bean...</span><span class="hljs-type">boolean</span> <span class="hljs-variable">resolved</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-type">boolean</span> <span class="hljs-variable">autowireNecessary</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-literal">null</span>) &#123;resolved = <span class="hljs-literal">true</span>;autowireNecessary = mbd.constructorArgumentsResolved;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (resolved) &#123;<span class="hljs-keyword">if</span> (autowireNecessary) &#123;<span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);&#125;&#125;<span class="hljs-comment">// Candidate constructors for autowiring?</span>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;<span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);&#125;<span class="hljs-comment">// Preferred constructors for default construction?</span>ctors = mbd.getPreferredConstructors();<span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="hljs-literal">null</span>);&#125;<span class="hljs-comment">// No special handling: simply use no-arg constructor.</span><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);&#125;</code></pre></div><h2 id="大致流程图"><a href="#大致流程图" class="headerlink" title="大致流程图"></a>大致流程图</h2><p><img src="/2022/09/06/spring/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20201212215421213.png" alt="简单流程图"></p><h2 id="详细流程图"><a href="#详细流程图" class="headerlink" title="详细流程图"></a>详细流程图</h2><img src="20201212215520379.png" alt="详细流程图"  />]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2的学习笔记</title>
    <link href="/2022/06/05/vue/vue2/"/>
    <url>/2022/06/05/vue/vue2/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue原理概述"><a href="#Vue原理概述" class="headerlink" title="Vue原理概述"></a>Vue原理概述</h2><p>当创建一个 Vue 实例时，你可以传入一个<strong>选项对象</strong>。这篇教程主要描述的就是如何使用这些选项来创建你想要的行为。作为参考，你也可以在 <a href="https://v2.cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">API 文档</a>中浏览完整的选项列表。</p><p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的：</p><div class="code-wrapper"><pre><code class="hljs">根实例└─ TodoList   ├─ TodoItem   │  ├─ TodoButtonDelete   │  └─ TodoButtonEdit   └─ TodoListFooter      ├─ TodosButtonClear      └─ TodoListStatistics</code></pre></div><p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><p>当这些数据改变时，视图会进行重渲染。值得注意的是<strong>只有当实例被创建时就已经存在于 <code>data</code> 中的 property 才是响应式的</strong>。也就是说如果你添加一个新的 property，比如：</p><div class="code-wrapper"><pre><code class="hljs vue">vm.b = &#x27;hi&#x27;</code></pre></div><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。</p><h2 id="脚手架结构"><a href="#脚手架结构" class="headerlink" title="脚手架结构"></a>脚手架结构</h2><div class="code-wrapper"><pre><code class="hljs stylus">├── node_modules ├── public│   ├── favicon<span class="hljs-selector-class">.ico</span>: 页签图标│   └── index<span class="hljs-selector-class">.html</span>: 主页面├── <span class="hljs-attribute">src</span>│   ├── assets: 存放静态资源│   │   └── logo<span class="hljs-selector-class">.png</span>│   │── component: 存放组件│   │   └── HelloWorld<span class="hljs-selector-class">.vue</span>│   │── App<span class="hljs-selector-class">.vue</span>: 汇总所有组件│   │── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>: 入口文件├── <span class="hljs-selector-class">.gitignore</span>: git版本管制忽略的配置├── babel<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>: babel的配置文件├── package<span class="hljs-selector-class">.json</span>: 应用包配置文件 ├── README<span class="hljs-selector-class">.md</span>: 应用描述文件├── package-lock.json：包版本控制文件</code></pre></div><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p><img src="/2022/06/05/vue/vue2/lifecycle.png" alt="vue生命周期图示"></p><h1 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h1><p>一个vue实例包含如下如下</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 使用 v-bind 绑定动态类名，对象式写法 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;className&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 计算属性，函数式写法 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>计算属性: &#123;&#123; computedProp &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;inputValue&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入内容&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 监听 v-on 指定的 DOM 事件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>点击按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 使用 v-for 循环渲染数据 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 父组件传入的 props --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件传入的 props: &#123;&#123; parentMsg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-comment">// 父组件传入的属性，对象式写法</span></span><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><span class="language-javascript">    <span class="hljs-attr">parentMsg</span>: <span class="hljs-title class_">String</span></span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 定义组件内部的数据</span></span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">inputValue</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;red&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">list</span>: [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>]</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 计算属性，函数式写法</span></span><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">computedProp</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>.<span class="hljs-title function_">toUpperCase</span>();</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 监听数据变化并执行相应的操作</span></span><span class="language-javascript">  <span class="hljs-attr">watch</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">inputValue</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`新的输入值：<span class="hljs-subst">$&#123;newVal&#125;</span>，旧的输入值：<span class="hljs-subst">$&#123;oldVal&#125;</span>`</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 定义组件中可复用的方法</span></span><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;按钮被点击了！&#x27;</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 在组件实例被创建时执行回调函数</span></span><span class="language-javascript">  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;created&#x27;</span>);</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 在组件挂载后执行回调函数</span></span><span class="language-javascript">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>);</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 可以使用该钩子来修改数据或者进行一些异步操作</span></span><span class="language-javascript">  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>);</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 当数据更新时被调用，可以在此处执行一些操作</span></span><span class="language-javascript">  <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>);</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-comment">// 当组件销毁时被调用</span></span><span class="language-javascript">  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;destroyed&#x27;</span>);</span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul><li><p>描述：在组件内部定义数据。</p></li><li><p>类型：Object | Function</p></li><li><p>用法：可以直接在 data 中定义一个对象或者函数。如果是函数，在调用时会返回一个对象，这样可以避免多个实例共享相同的数据。</p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">数据</a></p></li><li><p><strong>data的函数式与对象式</strong></p><p>  在Vue组件中，<strong>当你将 <code>data</code> 定义成一个对象时，这个数据对象在组件中的所有实例之间共享</strong>。这样，在多个实例之间使用相同的数据对象将会出现问题，因为所有实例都将引用相同的数据对象，这意味着如果其中一个实例改变了数据对象中的某个属性，那么它会影响其他所有实例。</p><p>  为了解决这个问题，你需要<strong>将 <code>data</code> 选项定义为一个返回数据对象的函数。这样每个实例都会调用该函数以获取其自己的数据副本</strong>，从而避免了多个实例之间共享相同的数据对象的问题。</p><p>  换句话说，当你将 <code>data</code> 选项定义为一个函数时，Vue在创建新组件实例时，会为每个实例分别调用该函数，以生成与该实例相关联的数据对象。这样就可以确保每个实例都有自己独立的数据副本，互不干扰。</p></li></ul><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ul><li><p>描述：由父组件传递到子组件中的参数。</p></li><li><p>类型：Object | Array</p></li><li><p>用法：在 props 中定义一个对象或者数组，分别表示从父组件接收到的参数名称和类型。</p></li><li><p><strong>使用props 传递参数</strong></p><p>  在Vue中，组件可以通过<code>props</code>来接收外部传递进来的数据。<code>props</code>是一个数组，在其中声明需要从父组件接收的属性。</p><p>  使用<code>props</code>可以将父组件的数据传递给子组件，实现了组件之间的数据交流。同时，通过在子组件设置<code>props</code>的类型、默认值等参数，可以对传入的数据进行校验和处理，确保程序正常运行。</p><p>  原理上，当父组件向子组件传递<code>prop</code>时，Vue会将这些属性包装为响应式对象，并将其注入到子组件实例中。在子组件中，可以像使用本地数据一样使用这些<code>props</code>，并且当父组件的数据发生变化时，这些变化也会反映到子组件中。</p><p>  需要注意的是，**由于Vue的单向数据流特性，子组件不能直接修改从父组件传递下来的<code>prop</code>**，否则会引起警告。如果需要在子组件中修改这些数据，可以通过在子组件中定义一个局部变量，并将<code>prop</code>的值复制给它来实现。</p></li></ul><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul><li>描述：根据依赖的数据动态生成新的属性值。通常用于依赖现有数据计算生成一个更复杂的数据。详细看<a href="https://v2.cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">计算属性</a></li><li>类型：Object</li><li>用法：在 computed 中定义一个对象，对象的 key 表示计算属性的名称，value 是一个函数，其返回值即为该计算属性的值。</li></ul><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul><li>描述：定义组件中可复用的方法。</li><li>类型：Object</li><li>用法：在 methods 中定义一个对象，其中每个属性名表示一个方法名，属性值是对应的函数。</li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul><li>描述：监听某个数据变化并执行相应的操作。详见<a href="https://v2.cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8">监听器</a></li><li>类型：Object</li><li>用法：在 watch 中定义一个对象，其中每个属性名表示需要监听的数据名称，属性值是一个函数，当数据变化时会自动调用该函数。</li></ul><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h3><ul><li>描述：用于触发父组件事件。</li><li>类型：Function</li><li>用法：在子组件中使用 <code>$emit</code> 方法，并传递参数来触发父组件中的指定事件。</li></ul><div class="code-wrapper"><pre><code class="hljs html">//假设我们有一个父组件 Parent 和一个子组件 Child，现在我们需要在子组件中触发一个事件，并将数据传递给父组件进行处理。此时我们可以在子组件中使用 $emit 方法来实现：// 子组件 Childmethods: &#123;  handleClick() &#123;    this.$emit(&#x27;child-click&#x27;, &#x27;hello world&#x27;)  &#125;&#125;// 父组件 Parent<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> @<span class="hljs-attr">child-click</span>=<span class="hljs-string">&quot;handleChildClick&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">handleChildClick</span>(<span class="hljs-params">data</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// 输出：&#x27;hello world&#x27;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h3 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h3><ul><li>描述：用于向响应式对象添加新属性，使它能够响应数据变化。</li><li>类型：Function</li><li>用法：调用 <code>$set</code> 方法，传递要添加属性的对象及属性名和属性值。</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">在 Vue.js 中，当我们使用对象或数组来更新组件数据时，Vue.js 会跟踪这些对象或数组的变化，并且自动更新组件的视图。但是，如果在对象或数组中添加新属性或元素时，Vue.js 并不会触发视图更新，因为 Vue.js 无法检测到这种直接添加的变化。</span><span class="hljs-comment"></span><span class="hljs-comment">这时候，就可以使用 $set 方法来告诉 Vue.js 改变了对象或数组，并触发视图更新。</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; user.name &#125;&#125; is &#123;&#123; user.age &#125;&#125; years old.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">user</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span></span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">updateName</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 直接修改对象属性，Vue.js 无法检测到变化</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jerry&#x27;</span></span><span class="language-javascript">      </span><span class="language-javascript">      <span class="hljs-comment">// 使用 $set 方法通知 Vue.js 对象发生了变化，并触发视图更新</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Jerry&#x27;</span>)</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-title function_">addHobby</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 直接添加数组元素，Vue.js 无法检测到变化</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">hobbies</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;reading&#x27;</span>)</span><span class="language-javascript">      </span><span class="language-javascript">      <span class="hljs-comment">// 使用 $set 方法通知 Vue.js 数组发生了变化，并触发视图更新</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">hobbies</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;swimming&#x27;</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">在上面的例子中，当点击按钮时，分别调用 updateName 和 addHobby 方法，在 updateName 方法中，直接修改了 user 对象的 name 属性，此时 Vue.js 无法检测到变化，需要使用 $set 方法通知 Vue.js 发生了变化；在 addHobby 方法中，直接向 user.hobbies 数组中添加元素，也需要使用 $set 方法通知 Vue.js 发生了变化。</span><span class="hljs-comment"></span><span class="hljs-comment">总之，使用 $set 方法可以让 Vue.js 能够检测到对象和数组的变化，并触发视图的更新。</span><span class="hljs-comment">--&gt;</span></code></pre></div><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h3><ul><li>描述：在 DOM 更新完成后执行回调函数。</li><li>类型：Function</li><li>用法：在需要等待 DOM 更新后再做一些操作的情况下，可以使用 <code>$nextTick</code> 方法，传递一个回调函数，在回调函数中进行相关操作。</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">$nextTick 是 Vue.js 提供的一个方法，用于在 DOM 更新之后执行回调函数。当你修改了数据并且想要等待 Vue.js 重新渲染 DOM 并完成相关的更新之后再执行一些操作时，可以使用 $nextTick。</span><span class="hljs-comment"></span><span class="hljs-comment">在 Vue.js 内部，当数据变化时，它并不会立即更新 DOM，而是异步执行更新，这样可以避免频繁的 DOM 操作导致页面性能降低。因此，如果需要在 DOM 更新后进行一些操作，就需要等待 Vue.js 更新完成。这时候就可以使用 $nextTick 来实现。</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, world!&#x27;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Updated message&#x27;</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 在 DOM 更新后进行一些操作</span></span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM updated&#x27;</span>)</span><span class="language-javascript">      &#125;)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">在上面的例子中，当点击按钮时，handleClick 方法被调用，将 message 的值改为 &#x27;Updated message&#x27;，然后在 $nextTick 回调函数中输出 &#x27;DOM updated&#x27;，这表示在 DOM 更新后才执行了该操作。</span><span class="hljs-comment">--&gt;</span></code></pre></div><h2 id="常见钩子"><a href="#常见钩子" class="headerlink" title="常见钩子"></a>常见钩子</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ul><li>描述：在实例初始化之后，数据观测 (data observer) 和事件配置之前被调用。</li><li>类型：Function</li><li>用法：在组件中定义 <code>beforeCreate</code> 钩子函数，在此钩子函数中可以执行一些初始化工作。</li></ul><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><ul><li>描述：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前尚不可用。</li><li>类型：Function</li><li>用法：在组件中定义 <code>created</code> 钩子函数，在此钩子函数中可以进一步处理数据或初始化组件。</li></ul><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul><li>描述：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>类型：Function</li><li>用法：在组件中定义 <code>beforeMount</code> 钩子函数，在此钩子函数中可以进一步处理数据或准备渲染组件。</li></ul><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul><li>描述：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。此时实例的数据和 DOM 已经被渲染完毕。</li><li>类型：Function</li><li>用法：在组件中定义 <code>mounted</code> 钩子函数，在此钩子函数中可以操作 DOM 或者初始化其他插件。</li></ul><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>描述：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中修改数据或者进行一些异步操作。</p><p>类型：Function</p><p>用法：在组件中定义 <code>beforeUpdate</code> 钩子函数，在此钩子函数中可以执行一些操作。</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul><li>描述：数据更新后调用，发生在实例更新之后，调用时组件 DOM 已经更新。要注意的是，这里不能进行数据修改操作，否则会导致死循环。</li><li>类型：Function</li><li>用法：在组件中定义 <code>updated</code> 钩子函数，在此钩子函数中可以处理 DOM 依赖的操作。</li></ul><h1 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h1><h2 id="v-model双向绑定"><a href="#v-model双向绑定" class="headerlink" title="v-model双向绑定"></a>v-model双向绑定</h2><p>双向绑定，input中改变了，就会改变data中的model，进而改变<p>中</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-6&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-comment">&lt;!--可以使用v-model.lazy进行懒加载--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-6&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span>  &#125;&#125;)</code></pre></div><p><img src="/2022/06/05/vue/vue2/image-20230313200244612.png" alt="image-20230313200244612"></p><h2 id="v-bind-绑定"><a href="#v-bind-绑定" class="headerlink" title="v-bind 绑定"></a>v-bind 绑定</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-2&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>    鼠标悬停几秒钟查看此处动态绑定的提示信息！  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-2&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;页面加载于 &#x27;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>()  &#125;&#125;)</code></pre></div><p>效果如图</p><p><img src="/2022/06/05/vue/vue2/image-20230313194815480.png" alt="image-20230313194815480"></p><h2 id="v-if-条件"><a href="#v-if-条件" class="headerlink" title="v-if 条件"></a>v-if 条件</h2><p><a href="https://v2.cn.vuejs.org/v2/guide/conditional.html">详见条件</a></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-3&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-3&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">seen</span>: <span class="hljs-literal">true</span>  &#125;&#125;)</code></pre></div><p>结果，现在你看见我了，成功显示出来</p><p>如果将seen设为false，则不会显示出来</p><h2 id="v-for-循环"><a href="#v-for-循环" class="headerlink" title="v-for 循环"></a>v-for 循环</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-4&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span>      &#123;&#123; todo.text &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-4&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">todos</span>: [      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 JavaScript&#x27;</span> &#125;,      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 Vue&#x27;</span> &#125;,      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;整个牛项目&#x27;</span> &#125;    ]  &#125;&#125;)</code></pre></div><p>结果是循环输出来了</p><p><img src="/2022/06/05/vue/vue2/image-20230313195409041.png" alt="image-20230313195409041"></p><h2 id="v-on-事件监听"><a href="#v-on-事件监听" class="headerlink" title="v-on 事件监听"></a>v-on 事件监听</h2><p>可以与监听事件搭配，触发方法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-5&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-5&#x27;</span>,  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue.js!&#x27;</span>  &#125;,  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)    &#125;  &#125;&#125;)</code></pre></div><p>结果</p><p><img src="/2022/06/05/vue/vue2/image-20230313195545539.png" alt="image-20230313195545539"></p><p>点击一下</p><p><img src="/2022/06/05/vue/vue2/image-20230313195603964.png" alt="image-20230313195603964"></p><p>更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，编写的代码只需要关注逻辑层面即可。</p><h2 id="v-slot-插槽"><a href="#v-slot-插槽" class="headerlink" title="v-slot 插槽"></a>v-slot 插槽</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在子组件中定义一个 Slot --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 如果没有提供内容，则会显示这里的默认内容 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Default Header<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-comment">&lt;!-- 在父组件中使用这个 Slot --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 使用 `v-slot` 来指定要填充哪个 Slot --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Custom Header<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>在这个例子中，子组件 <code>my-component</code> 定义了一个名为 <code>header</code> 的 Slot，并且在其中提供了一个默认的 <code>&lt;h1&gt;</code> 标题，如果父组件没有传入任何内容，就会使用这个默认内容。</p><p>父组件中使用了 <code>v-slot</code> 指令来填充 <code>header</code> Slot，将一个自定义的 <code>&lt;h1&gt;</code> 标题插入到子组件的 <code>header</code> Slot 中。这样，渲染出来的结果就是 <code>&lt;my-component&gt;</code> 组件内部的 <code>header</code> Slot 被替换成了父组件传入的内容。</p><p>总之，通过使用 Slot，我们可以让组件更加灵活和可重用，因为它们允许父组件动态地控制组件的输出内容。</p><h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>组件化，一个页面可以由多个组件构成，一个组件又可以由多个组件构成，为了复用组件</p><p><img src="/2022/06/05/vue/vue2/components.png"></p><p>组件一般放在components包下</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>这里定义了一个Student组件</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名：&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生年龄：&#123;&#123;age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Student&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">                <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,</span><span class="language-javascript">                <span class="hljs-attr">age</span>:<span class="hljs-number">18</span></span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>在另一个Info.vue文件中引用它</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//引入组件</span></span><span class="language-javascript">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Student.vue&quot;</span>;</span><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">            <span class="hljs-title class_">Student</span>,</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">    &#125;;  </span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>于是可以在Info.vue中看见相关信息了</p><h2 id="父作用域和子作用域间通讯"><a href="#父作用域和子作用域间通讯" class="headerlink" title="父作用域和子作用域间通讯"></a>父作用域和子作用域间通讯</h2><h3 id="prop-传递数据"><a href="#prop-传递数据" class="headerlink" title="prop 传递数据"></a>prop 传递数据</h3><p>Student.vue</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;todo.text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Student&quot;</span>,</span><span class="language-javascript">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;todo&#x27;</span>] </span><span class="language-javascript">&#125;;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>App.vue</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Student</span></span><span class="hljs-tag">      <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in groceryList&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">v-bind:todo</span>=<span class="hljs-string">&quot;item&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span></span><span class="hljs-tag">    &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Student.vue&quot;</span>;</span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title class_">Student</span>,</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">groceryList</span>: [</span><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;张三&#x27;</span> &#125;,</span><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;李四&#x27;</span> &#125;,</span><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;王五&#x27;</span> &#125;</span><span class="language-javascript">      ]</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">&#125;;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>这里使用props向子组件传递数据，props相当于子组件的属性，父组件，可以通过v-bind绑定</p><h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p>详见上述</p><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>Vue动态组件是指可以在运行时根据条件或用户交互动态切换不同的组件。使用动态组件可以让应用程序更灵活，具有更好的可扩展性和可维护性。</p><p>Vue中可以通过<code>&lt;component&gt;</code>标签来实现动态组件。<code>&lt;component&gt;</code>标签有一个特殊的属性<code>is</code>，它用来指定当前渲染的组件类型。当<code>is</code>属性发生变化时，<code>&lt;component&gt;</code>标签会自动重新渲染对应的组件。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleComponent&quot;</span>&gt;</span>Toggle Component<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/ComponentA.vue&#x27;</span></span><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentB</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/ComponentB.vue&#x27;</span></span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">currentComponent</span>: <span class="hljs-string">&#x27;ComponentA&#x27;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">toggleComponent</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentComponent</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentComponent</span> === <span class="hljs-string">&#x27;ComponentA&#x27;</span> ? <span class="hljs-string">&#x27;ComponentB&#x27;</span> : <span class="hljs-string">&#x27;ComponentA&#x27;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title class_">ComponentA</span>,</span><span class="language-javascript">    <span class="hljs-title class_">ComponentB</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>在这个示例中，我们定义了两个组件<code>ComponentA</code>和<code>ComponentB</code>，并将它们注册为本地组件。然后在父组件中，我们使用<code>&lt;component&gt;</code>标签来动态渲染当前选中的组件。当点击按钮时，我们将<code>currentComponent</code>属性切换为另一个组件名称，从而触发<code>&lt;component&gt;</code>标签的重新渲染。</p><p>值得注意的是，为了能够正确地渲染动态组件，每个组件都需要有一个唯一的<code>key</code>属性。<code>key</code>属性可以帮助Vue识别每个组件的唯一性，从而避免出现莫名其妙的渲染问题。</p><p>总之，Vue动态组件是非常有用和强大的特性，可以帮助我们构建更加灵活和可扩展的应用程序。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p>Vue 路由支持两种模式：hash 模式和 history 模式。默认情况下，Vue 路由使用 hash 模式。</p><h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><p>在 hash 模式下，URL 中会带有一个 <code>#</code> 号和后面的路径信息。例如：<code>http://localhost/#/about</code>。浏览器地址栏中的 <code>#</code> 号以及它后面的内容并不会被发送到服务器，而是由浏览器端解析处理。这样做的好处是，即使用户在页面中进行了操作导致 URL 发生变化，也不会向服务器发送请求，从而避免了刷新页面带来的延迟问题。</p><h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>在 history 模式下，URL 中不再带有 <code>#</code> 号，而是直接显示路径信息。例如：<code>http://localhost/about</code>。这种模式需要服务端对所有可能的路径都进行设置，否则访问不存在的路径时就会报错。在使用 history 模式时，如果需要在本地开发环境中调试，需要配置 web 服务器支持单页应用的路由。如：配置 nginx、Apache 或使用 express 等 Node.js 服务器。</p><p>可以通过在创建 VueRouter 实例时传递 <code>mode</code> 参数来指定路由模式。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,  <span class="hljs-attr">routes</span>: [...]&#125;)</code></pre></div><h2 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h2><p>为了使用Vue Router，我们需要先安装它：</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> vue-router</code></pre></div><p>然后，在我们的Vue.js应用程序中，我们需要创建Vue Router实例并将其导入我们的Vue实例中。我们可以使用Vue.use()方法来注册Vue Router插件，并将router对象传递给我们的Vue实例。</p><p>下面是一个基本的示例：</p><ol><li><p>在src下新建router包，其中新建路由文件index.js</p> <div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 该文件专门用于创建整个应用的路由器</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-comment">//引入组件</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Student&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">School</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/School&#x27;</span>;<span class="hljs-comment">//创建并暴露一个路由器</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;    <span class="hljs-attr">routes</span>: [        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/student&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Student</span>        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/school&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-title class_">School</span>        &#125;    ]&#125;)</code></pre></div></li><li><p>在mian.js中引用路由</p> <div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-comment">//引入vue router</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><span class="hljs-comment">//关闭Vue的生产提示</span><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><span class="hljs-comment">//使用vue-router</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<span class="hljs-comment">//创建vm</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),  router : router,&#125;)</code></pre></div></li><li><p>新建两个组件School、Student</p></li><li><p>在App.vue中引用</p> <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-xs-2 col-xs-offset-2&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/student&quot;</span>&gt;</span>Student<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/school&quot;</span>&gt;</span>School<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-xs-6&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel-body&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 指定组件的呈现位置 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span><span class="language-javascript">&#125;;  </span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ol><p>在这个例子中，我们首先从Vue包中导入Vue和VueRouter模块。然后，我们使用Vue.use()方法来注册Vue Router插件。接着，我们定义了我们的路由数组，并在每个路由上指定了路径、名称和组件。最后，我们创建一个新的Vue Router实例，并将路由数组传递给它。我们将该实例导出，以便我们可以在我们的应用程序中使用它。</p><p>在我们的Vue组件中，我们可以通过router属性来访问VueRouter实例。例如，我们可以使用router.push()方法来在组件之间进行导航：</p><div class="code-wrapper"><pre><code class="hljs arcade">this.<span class="hljs-symbol">$router</span>.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;/about&#x27;</span>)</code></pre></div><p>这将会将URL更改为“&#x2F;about”，并加载关联的组件。</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>动态路由是指路由路径中包含参数的情况，例如 <code>/user/:id</code>。其中，<code>:id</code> 就是参数名称。当用户访问 <code>/user/123</code> 这样的路径时，实际上会进入到 <code>User</code> 组件，并且该组件内可以通过 <code>$route.params.id</code> 获取到参数的值。</p><p>我们可以在路由表中使用 <code>:</code> 来定义动态参数，例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;]</code></pre></div><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>嵌套路由是指在一个路由下还有其它子路由的情况，例如一个电商网站的订单页面，可能需要进一步展示订单详情、发货信息等子页面。在 Vue 路由中，可以通过 <code>children</code> 属性来定义嵌套路由。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/order&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Order</span>,    <span class="hljs-attr">children</span>: [      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;detail&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">OrderDetail</span> &#125;,      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;shipping&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">ShippingInfo</span> &#125;    ]  &#125;]</code></pre></div><p>在上述路由表中，<code>/order/detail</code> 和 <code>/order/shipping</code> 都是 <code>Order</code> 组件的子组件。因此，在 <code>Order</code> 组件中可以使用 <code>&lt;router-view&gt;</code> 标签来渲染子组件。</p><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>Vue Router提供了导航守卫，这些守卫允许我们在组件之间导航时执行操作。例如，我们可以使用“beforeEach”导航守卫来检查用户是否已经登录，如果没有，则将其重定向到登录页面：</p><div class="code-wrapper"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>)  <span class="hljs-comment">// 如果用户未登录且访问需要权限的页面，则重定向到登录页面</span>  <span class="hljs-keyword">if</span> (!token &amp;&amp; to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span>) &#123;     <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">next</span>()  &#125;&#125;)</code></pre></div><p>在这个例子中，我们检查每个要访问的路由记录上是否有requiresAuth元数据标记。如果有，则检查用户是否已经登录。如果未登录，则将用户重定向到登录页面，并在queryString中存储原始请求路径。</p><p>导航守卫是指在路由跳转前或跳转后执行的一些额外逻辑。Vue 路由提供了三个全局导航守卫：<code>beforeEach</code>、<code>beforeResolve</code> 和 <code>afterEach</code>，以及每个路由组件内部的导航守卫：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code>。</p><ul><li><p><code>beforeEach(to, from, next)</code>：在所有路由跳转前都会执行，可以用来判断用户是否登录等操作。</p></li><li><p><code>beforeResolve(to, from, next)</code>：在所有异步路由组件被解析之后，路由跳转前被调用。</p></li><li><p><code>afterEach(to, from)</code>：在路由跳转完成后被调用，可以用来进行一些异步操作。</p></li><li><p><code>beforeRouteEnter(to, from, next)</code>：在路由进入组件前被调用，可以用来获取数据等操作。</p></li><li><p><code>beforeRouteUpdate(to, from, next)</code>：在同一个路由组件内跳转路</p></li></ul><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>在大型应用程序中，我们可能有数十个甚至数百个组件，这些组件不会全部在应用程序启动时加载。为了提高性能，我们可以使用Vue Router的路由懒加载功能，仅在需要时加载组件代码。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Foo</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)</code></pre></div><p>在这里，我们使用“import()”语法来动态地加载Foo组件。当用户访问该路由时，只有在需要时才会下载和解析组件代码。</p><p>总的来说，Vue Router是一个非常强大和灵活的工具，可以帮助我们构建复杂的单页应用程序和动态路由。</p><h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><h2 id="Props-x2F-Events"><a href="#Props-x2F-Events" class="headerlink" title="Props&#x2F;Events"></a>Props&#x2F;Events</h2><p>父组件通过 props 将数据传递给子组件，子组件通过 $emit 触发事件来通知父组件。这种方式适合父子组件之间的通信。详见上述。</p><h2 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h2><p>在Vue中创建一个空的Vue实例作为总线，在需要通信的组件中分别引入并使用该实例来触发和监听事件，从而实现任意两个组件之间的通信。这种方式适合非父子组件之间的通信。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在Vue中，你可以使用事件总线（Event Bus）来处理组件之间的通信。以下是一个简单的示例代码，演示了如何使用事件总线在两个组件之间通信：</p><ol><li>首先，在Vue应用程序的根组件中创建Event Bus实例，并将其导出给所有子组件使用：</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();</code></pre></div><ol start="2"><li>然后，在需要进行通信的组件中（例如，组件A和组件B），你可以注册自己的事件监听器并发布事件：</li></ol><p>组件A：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-string">&#x27;Hello World!&#x27;</span>);    &#125;  &#125;&#125;</code></pre></div><p>组件B：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received event with data:&#x27;</span>, data);    &#125;);  &#125;&#125;</code></pre></div><p>在上面的示例中，我们首先导入了Event Bus实例，然后将“my-event”事件注册到组件A的单击事件中。当用户单击组件A时，它会通过Event Bus发布一个新的“my-event”事件，并传递字符串“Hello World!”作为数据。</p><p>然后，我们在组件B中注册了一个事件监听器以接收“my-event”事件。当Event Bus接收到新事件时，它将调用回调函数并传递事件数据。在这种情况下，我们仅将数据打印到控制台上。</p><p>请注意，由于Event Bus是一个全局Vue实例，所以你可以在应用程序的任何组件中使用它。这使得它成为一种非常方便的工具来处理不同组件之间的通信。</p><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><ol><li>传递复杂数据：如果你需要在组件之间传递复杂的数据结构，例如对象或数组，你可以将它们作为单个事件参数传递。在接收事件的组件中，你可以使用解构赋值语法来提取所需的数据。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 发布事件</span><span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;my-event&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;);<span class="hljs-comment">// 接收事件</span><span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123; name, age &#125; = data;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received event with name <span class="hljs-subst">$&#123;name&#125;</span> and age <span class="hljs-subst">$&#123;age&#125;</span>`</span>);&#125;);</code></pre></div><ol start="2"><li>使用别名：如果你不想在每个.vue文件中都导入Event Bus实例，你可以将其定义为全局Vue插件，并使用别名来访问它。这样做可以帮助你更好地组织和管理你的代码。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义插件并设置别名</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(&#123;  <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) &#123;    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();  &#125;&#125;, <span class="hljs-string">&#x27;$bus&#x27;</span>);<span class="hljs-comment">// 在组件中使用别名</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received my-event&#x27;</span>);    &#125;);  &#125;&#125;</code></pre></div><ol start="3"><li>取消事件监听器：如果你需要在某个时刻取消已注册的事件监听器，你可以使用“$off”方法。你可以传递事件类型和回调函数来指定要取消的事件监听器。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 注册事件监听器</span><span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received my-event&#x27;</span>);&#125;);<span class="hljs-comment">// 取消事件监听器</span><span class="hljs-title class_">EventBus</span>.$off(<span class="hljs-string">&#x27;my-event&#x27;</span>);</code></pre></div><ol start="4"><li>全局事件钩子：如果你需要在整个应用程序中监听某些事件（例如路由切换、用户登录等），你可以使用Vue的全局事件钩子来完成。你可以在Vue实例上注册全局事件钩子，以便在特定生命周期钩子函数被调用时自动执行特定操作。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 注册全局事件钩子</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;component-mounted&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">name</span>);  &#125;&#125;);<span class="hljs-comment">// 接收事件</span><span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;component-mounted&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">componentName</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Component <span class="hljs-subst">$&#123;componentName&#125;</span> has been mounted`</span>);&#125;);</code></pre></div><p>总的来说，Vue的事件总线是一个非常强大的工具，可以帮助你更好地管理和组织组件之间的通信，并提高应用程序的可维护性和可扩展性。</p><h3 id="使用命名空间划分store"><a href="#使用命名空间划分store" class="headerlink" title="使用命名空间划分store"></a>使用命名空间划分store</h3><p>在Vue中，每个应用只能有一个唯一的Vuex.Store实例。这是因为Vuex.Store是全局的状态管理器，负责管理整个应用的状态数据。如果创建多个Vuex.Store实例，会导致状态数据的混乱和不可预测行为。</p><p>如果需要隔离使用多个状态管理器，可以考虑使用命名空间（namespace）来划分模块。在Vuex中，一个Vuex.Store实例包含多个module，每个module都可以拥有自己的state、mutations、actions和getters，并且还可以嵌套其他module。通过给每个module设置唯一的命名空间，就可以实现状态数据的隔离。</p><p>例如，可以创建两个module，分别命名为”moduleA”和”moduleB”，并且为它们设置不同的命名空间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">moduleA</span>: &#123;      <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">state</span>: &#123; ... &#125;,      <span class="hljs-attr">mutations</span>: &#123; ... &#125;,      <span class="hljs-attr">actions</span>: &#123; ... &#125;,      <span class="hljs-attr">getters</span>: &#123; ... &#125;    &#125;,    <span class="hljs-attr">moduleB</span>: &#123;      <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">state</span>: &#123; ... &#125;,      <span class="hljs-attr">mutations</span>: &#123; ... &#125;,      <span class="hljs-attr">actions</span>: &#123; ... &#125;,      <span class="hljs-attr">getters</span>: &#123; ... &#125;    &#125;  &#125;&#125;)</code></pre></div><p>然后，在组件中访问moduleA和moduleB的状态或者执行它们的操作时，需要加上命名空间前缀：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">moduleA</span>.<span class="hljs-property">xxx</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;moduleB/actionName&#x27;</span>, payload)</code></pre></div><p>这样就可以实现多个状态管理器的隔离使用。</p><h3 id="多个Store，模块化使用"><a href="#多个Store，模块化使用" class="headerlink" title="多个Store，模块化使用"></a>多个Store，模块化使用</h3><p>在 Vue 中是可以有多个 Vuex.Store 的，每个 Store 可以独立维护自己的状态。通常情况下一个应用只需要一个 Store 就足够了，但在一些复杂的场景中可能需要使用多个 Store 来分别管理不同的状态。</p><p>以下是一个示例：</p><p>假设我们有两个页面：Page A 和 Page B，它们分别位于 src&#x2F;pages&#x2F;PageA.vue 和 src&#x2F;pages&#x2F;PageB.vue 文件中。</p><p>我们可以为每个页面创建单独的 Store，并将其存储在不同的 js 文件中。例如，PageA 需要一个名为 pageAStore 的 Store，而 PageB 需要一个名为 pageBStore 的 Store。</p><p>在 src&#x2F;store 目录中新建两个文件：</p><p>pageAStore.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">count</span>++    &#125;  &#125;&#125;)</code></pre></div><p>pageBStore.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params">state, payload</span>) &#123;      state.<span class="hljs-property">message</span> = payload    &#125;  &#125;&#125;)</code></pre></div><p>然后在 PageA 和 PageB 中分别导入对应的 Store：</p><p>PageA.vue</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Page A<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">import</span> pageAStore <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store/pageAStore&#x27;</span></span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">store</span>: pageAStore</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>PageB.vue</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Page B<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;newMessage&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span>Update Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">import</span> pageBStore <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store/pageBStore&#x27;</span></span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">store</span>: pageBStore,</span><span class="language-javascript">      <span class="hljs-attr">newMessage</span>: <span class="hljs-string">&#x27;&#x27;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">message</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">    <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;updateMessage&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">newMessage</span>)</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">newMessage</span> = <span class="hljs-string">&#x27;&#x27;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>注意，在每个页面组件中，我们需要将对应的 Store 对象赋值给组件实例的 data 属性中的 store，这样我们就可以通过 this.store 访问该页面的 Store 实例。</p><p>使用这种方式，我们就可以在不同的页面中使用不同的 Vuex.Store，并且它们互不干扰，从而更好地达到状态管理的目的。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是 Vue.js 的官方状态管理工具，提供了一个集中式存储管理应用的所有组件的状态，通过 mutations 来修改状态，通过 getters 来获取状态，通过 actions 来提交 mutations，从而实现组件之间的共享状态和通信。</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>在使用 Vuex 之前，需要先安装和引入它：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 安装</span>npm install vuex --save<span class="hljs-comment">// 引入</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)</code></pre></div><p>接下来，在创建 Vue 实例之前，需要定义一个 store：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">count</span>++    &#125;  &#125;,  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)      &#125;, <span class="hljs-number">1000</span>)    &#125;  &#125;,  <span class="hljs-attr">getters</span>: &#123;    <span class="hljs-attr">doubleCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>  &#125;&#125;)</code></pre></div><p>上面的代码中，我们先定义了一个 state 对象，其中包含了应用程序的状态数据。然后定义了一个 mutation 函数（increment），它是唯一能够修改 state 的函数，必须是同步函数。还定义了一个 action 函数（incrementAsync）用于异步提交 mutation，这里使用了 ES6 的解构语法。最后定义了一个 getter 函数（doubleCount），它是从 state 获取派生状态的函数。</p><p>最后，在 Vue 实例中，将 store 注入到根组件中即可：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,  store,  <span class="hljs-attr">computed</span>: &#123;    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>    &#125;,    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>    &#125;  &#125;,  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)    &#125;,    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;incrementAsync&#x27;</span>)    &#125;  &#125;&#125;)</code></pre></div><h3 id="进阶使用-1"><a href="#进阶使用-1" class="headerlink" title="进阶使用"></a>进阶使用</h3><p>除了基本使用外，Vuex 还支持模块化、插件等更高级的功能。</p><ol><li>模块化：当应用程序变得非常复杂时，可以将 store 拆分成多个模块，每个模块都有自己的 state、mutation、action、getter 等。这样做有助于提高代码的可维护性和可扩展性。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-attr">state</span>: &#123; ... &#125;,  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;,  <span class="hljs-attr">getters</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> moduleB = &#123;  <span class="hljs-attr">state</span>: &#123; ... &#125;,  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;,  <span class="hljs-attr">getters</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">a</span>: moduleA,    <span class="hljs-attr">b</span>: moduleB  &#125;&#125;)</code></pre></div><ol><li>插件：Vuex 允许开发者编写插件来扩展其功能。插件可以监听 mutation、提交 mutation、替换 mutation 等。例如，可以编写一个插件来实现状态持久化功能，将 state 存储在 localStorage 中。</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPlugin</span> = store =&gt; &#123;  <span class="hljs-comment">// 监听 mutation</span>  store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 在 mutation 后将 state 存储到 localStorage 中</span>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))  &#125;)  <span class="hljs-comment">// 替换 mutation</span>  store.<span class="hljs-title function_">replaceMutation</span>(<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">state, payload</span>) =&gt;</span> &#123;    state.<span class="hljs-property">count</span> += payload.<span class="hljs-property">amount</span>  &#125;)&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123; ... &#125;,  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">plugins</span>: [myPlugin]&#125;)</code></pre></div><p>总之，Vuex 是一个功能强大、易于使用的状态管理库，不仅可以帮助我们更好地管理和维护 Vue 应用程序中的共享状态，还支持模块化、插件等高级功能，使应用程序的架构设计更加优雅和灵活。</p><h2 id="Provide-x2F-Inject"><a href="#Provide-x2F-Inject" class="headerlink" title="Provide&#x2F;Inject"></a>Provide&#x2F;Inject</h2><p>父组件通过 provide 提供数据，子组件通过 inject 注入数据。这种方式可以将数据注入到所有后代组件中，而不必在每个组件中显式地传递数据。</p><h2 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h2><p>每个Vue组件都有一个 $refs 属性，该属性可以访问组件实例，并且可以在父组件中直接访问子组件或在子组件中访问父组件，从而实现组件之间的通信。</p><h2 id="parent-x2F-children"><a href="#parent-x2F-children" class="headerlink" title="$parent&#x2F;children"></a>$parent&#x2F;children</h2><p>每个Vue组件实例都有 $parent 和 $children 属性，可以通过这些属性访问父组件和子组件，从而实现组件之间的通信。</p><h1 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h1><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​在vue.config.js中添加如下配置：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>:&#123;  <span class="hljs-attr">proxy</span>:<span class="hljs-string">&quot;http://localhost:5000&quot;</span>&#125;</code></pre></div><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​编写vue.config.js配置具体代理规则：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<span class="hljs-attr">devServer</span>: &#123;      <span class="hljs-attr">proxy</span>: &#123;      <span class="hljs-string">&#x27;/api1&#x27;</span>: &#123;<span class="hljs-comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,<span class="hljs-comment">// 代理目标的基础路径</span>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api1&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;      &#125;,      <span class="hljs-string">&#x27;/api2&#x27;</span>: &#123;<span class="hljs-comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<span class="hljs-comment">// 代理目标的基础路径</span>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api2&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span><span class="hljs-comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span><span class="hljs-comment">   changeOrigin默认值为true</span><span class="hljs-comment">*/</span></code></pre></div><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="使用axios-1"><a href="#使用axios-1" class="headerlink" title="使用axios"></a>使用axios</h2><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,        <span class="hljs-attr">methods</span>:&#123;            <span class="hljs-title function_">getStudents</span>(<span class="hljs-params"></span>)&#123;                axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/students&#x27;</span>)                    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;                    <span class="hljs-comment">// 处理成功情况</span>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);                &#125;)                    .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;                    <span class="hljs-comment">// 处理错误情况</span>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);                &#125;)                    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finial&#x27;</span>);                    <span class="hljs-comment">// 总是会执行</span>                &#125;);            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap及CurrentHashMap详解</title>
    <link href="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/"/>
    <url>/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYWQ5OWNmNTRiN2RkNDI2NjIzMDE1ODY3NDI1ODUucG5n" alt="hashmap在1.8"></p><p>hashmap中基础架构</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，</span><span class="hljs-comment">* 如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），</span><span class="hljs-comment">* 需要抛出异常ConcurrentModificationException</span><span class="hljs-comment">*/</span><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<span class="hljs-comment">//默认的初始化容量为16，必须是2的n次幂</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">//最大容量为 2^30</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">//默认的加载因子0.75，乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容。</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<span class="hljs-comment">//刚才提到了当链表长度过长时，会有一个阈值，超过这个阈值8就会转化为红黑树</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//当红黑树上的元素个数，减少到6个时，就退化为链表</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<span class="hljs-comment">//链表转化为红黑树，除了有阈值的限制，还有另外一个限制，需要数组容量至少达到64，才会树化。</span><span class="hljs-comment">//这是为了避免，数组扩容和树化阈值之间的冲突。</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<span class="hljs-comment">//存放所有Node节点的数组</span><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="hljs-comment">//存放所有的键值对</span><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<span class="hljs-comment">//map中的实际键值对个数，即数组中元素个数</span><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">//每次结构改变时，都会自增，fail-fast机制，这是一种错误检测机制。</span><span class="hljs-comment">//当迭代集合的时候，如果结构发生改变，则会发生 fail-fast，抛出异常。</span><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<span class="hljs-comment">//数组扩容阈值</span><span class="hljs-type">int</span> threshold;<span class="hljs-comment">//加载因子</span><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<span class="hljs-comment">//普通单向链表节点类</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<span class="hljs-comment">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<span class="hljs-keyword">final</span> K key;V value;<span class="hljs-comment">//指向单链表的下一个节点</span>Node&lt;K,V&gt; next;Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<span class="hljs-built_in">this</span>.hash = hash;<span class="hljs-built_in">this</span>.key = key;<span class="hljs-built_in">this</span>.value = value;<span class="hljs-built_in">this</span>.next = next;&#125;&#125;<span class="hljs-comment">//转化为红黑树的节点类</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<span class="hljs-comment">//当前节点的父节点</span>TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">//左孩子节点</span>TreeNode&lt;K,V&gt; left;<span class="hljs-comment">//右孩子节点</span>TreeNode&lt;K,V&gt; right;<span class="hljs-comment">//指向前一个节点</span>TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><span class="hljs-comment">//当前节点是红色或者黑色的标识</span><span class="hljs-type">boolean</span> red;TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<span class="hljs-built_in">super</span>(hash, key, val, next);&#125;&#125;</code></pre></div><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><ol><li><p>创建一个默认负载因子的对象</p> <div class="code-wrapper"><pre><code class="hljs java">/<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">//构造一个具有默认初始容量(16)和默认负载因子(0.75)的空HashMap。</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>&#125;</code></pre></div></li></ol><h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将指定值与此映射中的指定键关联。如果先前的映射包含键的映射，则替换旧值。</span><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    <span class="hljs-comment">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，用于确定当前key应该存放在数组的哪个下标位置</span>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);&#125;<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;    <span class="hljs-comment">//懒加载初始化</span>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;    <span class="hljs-comment">//判断table是否为空，如果空的话，会先调用resize扩容</span>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            n = (tab = resize()).length;    <span class="hljs-comment">//根据当前key的hash值找到它在数组中的下标，判断当前下标位置是否已经存在元素，</span><span class="hljs-comment">//若没有，则把key、value包装成Node节点，直接添加到此位置。</span>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果当前位置已经有元素了，分为三种情况。</span>            Node&lt;K,V&gt; e; K k;            <span class="hljs-comment">//1.当前位置元素的hash值等于传过来的hash，并且他们的key值也相等，</span>            <span class="hljs-comment">//则把p赋值给e，跳转到①处，后续需要做值的覆盖处理</span>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                e = p;            <span class="hljs-comment">//2.如果当前是红黑树结构，则把它加入到红黑树 </span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//3.说明此位置已存在元素，并且是普通链表结构，则采用尾插法，把新节点加入到链表尾部</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);                        <span class="hljs-comment">//如果在插入的过程中，链表长度超过了8，则转化为红黑树</span>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// ============================转换成树</span>                            treeifyBin(tab, hash);                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                        <span class="hljs-comment">//若在链表中找到了相同key的话，直接退出循环，跳转到①处</span>                        <span class="hljs-keyword">break</span>;                    p = e;                &#125;            &#125;            <span class="hljs-comment">//①</span>            <span class="hljs-comment">//说明发生了碰撞，e代表的是旧值，因此节点位置不变，但是需要替换为新值</span>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;                <span class="hljs-comment">//用新值替换旧值，并返回旧值。</span>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)                    e.value = value;                <span class="hljs-comment">//看方法名字即可知，这是在node被访问之后需要做的操作。其实此处是一个空实现，</span>                <span class="hljs-comment">//只有在 LinkedHashMap才会实现，用于实现根据访问先后顺序对元素进行排序，hashmap不提供排序功能</span>                afterNodeAccess(e);                <span class="hljs-keyword">return</span> oldValue;            &#125;        &#125;    <span class="hljs-comment">//快速失败策略，每次对hashmap进行修改的时候这个参数都会自增</span>        ++modCount;    <span class="hljs-comment">//如果当前数组中的元素个数超过阈值，则扩容</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)            resize();    <span class="hljs-comment">//同样的空实现</span>        afterNodeInsertion(evict);        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;</code></pre></div><h3 id="hash-计算"><a href="#hash-计算" class="headerlink" title="hash()计算"></a>hash()计算</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<span class="hljs-type">int</span> h;<span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;</code></pre></div><h3 id="resize（）"><a href="#resize（）" class="headerlink" title="resize（）"></a>resize（）</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    <span class="hljs-comment">//旧数组</span>    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-comment">//旧数组的容量</span>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-comment">//旧数组的扩容阈值，注意看，这里取的是当前对象的 threshold 值，下边的第2种情况会用到。</span>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;    <span class="hljs-comment">//初始化新数组的容量和阈值，分三种情况讨论。</span>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-comment">//1.当旧数组的容量大于0时，说明在这之前肯定调用过 resize扩容过一次，才会导致旧容量不为0。</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//容量达到了最大值</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">//新数组的容量和阈值都扩大原来的2倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">//2.到这里，说明 oldCap &lt;= 0，并且 oldThr(threshold) &gt; 0，这就是 map 初始化的时候，第一次调用 resize的情况</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>        newCap = oldThr;    <span class="hljs-comment">//3.到这里，说明 oldCap 和 oldThr 都是小于等于0的。也说明我们的map是通过默认无参构造来创建的，</span>    <span class="hljs-comment">//于是，数组的容量和阈值都取默认值就可以了，即 16 和 12。</span>    <span class="hljs-keyword">else</span> &#123;                       newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;        <span class="hljs-comment">//③ 这里就是处理第2种情况，因为只有这种情况 newThr 才为0，</span><span class="hljs-comment">//因此计算 newThr（用 newCap即16 乘以加载因子 0.75，得到 12） ，并把它赋值给 threshold</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);    &#125;    <span class="hljs-comment">//赋予 threshold 正确的值，表示数组下次需要扩容的阈值（此时就把原来的 16 修正为了 12）。</span>    threshold = newThr;    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>    <span class="hljs-comment">//在构造函数时，并没有创建数组，在第一次调用put方法，导致resize的时候，才会把数组创建出来。这是为了懒加载，提高效率。</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];    table = newTab;            <span class="hljs-comment">//如果原来的数组不为空，那么我们就需要把原来数组中的元素重新分配到新的数组中</span><span class="hljs-comment">//如果是第2种情况，由于是第一次调用resize，此时数组肯定是空的，因此也就不需要重新分配元素。</span>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-comment">//取到当前下标的第一个元素，如果存在，则分三种情况重新分配位置</span>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;                <span class="hljs-comment">//1.如果当前元素的下一个元素为空，则说明此处只有一个元素</span>                <span class="hljs-comment">//则直接用它的hash()值和新数组的容量取模就可以了，得到新的下标位置。</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                                <span class="hljs-comment">//2.如果是红黑树结构，则拆分红黑树，必要时有可能退化为链表</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);                                <span class="hljs-comment">//3.到这里说明，这是一个长度大于 1 的普通链表，则需要计算并</span>                <span class="hljs-comment">//判断当前位置的链表是否需要移动到新的位置</span>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    <span class="hljs-comment">// loHead 和 loTail 分别代表链表旧位置的头尾节点</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// hiHead 和 hiTail 分别代表链表移动到新位置的头尾节点</span>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-comment">//如果当前元素的hash值和oldCap做与运算为0，则原位置不变</span>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-comment">//否则，需要移动到新的位置</span>                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-comment">//原位置不变的一条链表，数组下标不变</span>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">//移动到新位置的一条链表，数组下标为原下标加上旧数组的容量</span>    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre></div><h3 id="get（）"><a href="#get（）" class="headerlink" title="get（）"></a>get（）</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;    Node&lt;K,V&gt; e;    <span class="hljs-comment">//如果节点为空，则返回null，否则返回节点的value。这也说明，hashMap是支持value为null的。</span>    <span class="hljs-comment">//因此，我们就明白了，为什么hashMap支持Key和value都为null</span>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;&#125;<span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;    <span class="hljs-comment">//首先要确保数组不能为空，然后取到当前hash值计算出来的下标位置的第一个元素</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//若hash值和key都相等，则说明我们要找的就是第一个元素，直接返回</span>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-keyword">return</span> first;        <span class="hljs-comment">//如果不是的话，就遍历当前链表（或红黑树）</span>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//如果是红黑树结构，则找到当前key所在的节点位置</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-comment">//如果是普通链表，则向后遍历查找，直到找到或者遍历到链表末尾为止。</span>            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-comment">//否则，说明没有找到，返回null</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h3 id="快速失败原理"><a href="#快速失败原理" class="headerlink" title="快速失败原理"></a>快速失败原理</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;V&gt; &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> nextNode().value; &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span> &#123;    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span>    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span>    <span class="hljs-type">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span>    <span class="hljs-type">int</span> index;             <span class="hljs-comment">// current slot</span>    HashIterator() &#123;        <span class="hljs-comment">//在构造迭代器的时候，将modCount值赋值给expectedModCount</span>        expectedModCount = modCount;        Node&lt;K,V&gt;[] t = table;        current = next = <span class="hljs-literal">null</span>;        index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">nextNode</span><span class="hljs-params">()</span> &#123;        Node&lt;K,V&gt;[] t;        Node&lt;K,V&gt; e = next;        <span class="hljs-comment">//在获取下一个节点前，先判定modCount值是否修改，如果被修改了则抛出ConcurrentModificationException异常，从前面可以知道，当修改了HashMap的时候，都会修改modCount值。</span>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-literal">null</span> &amp;&amp; (t = table) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);        &#125;        <span class="hljs-keyword">return</span> e;    &#125;    <span class="hljs-comment">//迭代器的删除操作，会重新给exceptedModCount赋值，因此不会导致fast-fail</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;        Node&lt;K,V&gt; p = current;        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();        <span class="hljs-comment">//先判定modCount值是否被修改了</span>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();        current = <span class="hljs-literal">null</span>;        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> p.key;        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);        <span class="hljs-comment">//将modCount值重新赋值给expectedModCount，这样下次迭代时，不会出现fast-fail</span>        expectedModCount = modCount;    &#125;&#125;</code></pre></div><p>每次修改hashmap的时候，modCount都会自增一次，而迭代器迭代下一个元素之前都会比较modCount，如果不一样则说明已经被修改了，于是直接抛出错误。</p><h3 id="主要变化及原理解释"><a href="#主要变化及原理解释" class="headerlink" title="主要变化及原理解释"></a>主要变化及原理解释</h3><h4 id="为什么要改成“数组-链表-红黑树”？"><a href="#为什么要改成“数组-链表-红黑树”？" class="headerlink" title="为什么要改成“数组+链表+红黑树”？"></a>为什么要改成“数组+链表+红黑树”？</h4><p>主要是为了提升在hash冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</p><h4 id="链表红黑树之间的转换"><a href="#链表红黑树之间的转换" class="headerlink" title="链表红黑树之间的转换"></a>链表红黑树之间的转换</h4><p>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</p><p>对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。</p><h4 id="为什么链表转红黑树的阈值是8？"><a href="#为什么链表转红黑树的阈值是8？" class="headerlink" title="为什么链表转红黑树的阈值是8？"></a>为什么链表转红黑树的阈值是8？</h4><p>红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价作者觉得不值得。</p><h4 id="为什么转回链表节点是用的6而不是复用8？"><a href="#为什么转回链表节点是用的6而不是复用8？" class="headerlink" title="为什么转回链表节点是用的6而不是复用8？"></a>为什么转回链表节点是用的6而不是复用8？</h4><p>如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在8徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗。</p><h4 id="HashMap-的初始容量是多少？"><a href="#HashMap-的初始容量是多少？" class="headerlink" title="HashMap 的初始容量是多少？"></a>HashMap 的初始容量是多少？</h4><p>默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16。</p><h4 id="介绍一下死循环问题"><a href="#介绍一下死循环问题" class="headerlink" title="介绍一下死循环问题"></a>介绍一下死循环问题</h4><p>导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMzkyNTZmOTVhOGFiMjEzNTcxMDE1ODcwNTIxNjgucG5n" alt="JDK7的ConcurrentHashMap"></p><p>从整体来看，它是一个由 Segment 组成的数组。然后，每个 Segment 里边是由 HashEntry 组成的数组，每个 HashEntry之间又可以形成链表。我们可以把每个 Segment 看成是一个小的 HashMap，其内部结构和 HashMap 是一模一样的。ConcurrentHashMap的segment一经创建数量就不会再改变。</p><p>ReentrantLock+CAS+分段思想来保证的并发安全的，ConcurrentHashMap的put方法会通过CAS的方式，把一个Segment对象存到Segment数组中，一个Segment内部存在一个HashEntry数组，相当于分段的HashMap，Segment继承了ReentrantLock，每段put开始会加锁。故而称之为分段锁。</p><h4 id="Put（）"><a href="#Put（）" class="headerlink" title="Put（）"></a>Put（）</h4><ol><li>通过哈希算法计算出当前 key 的 hash 值</li><li>通过这个 hash 值找到它所对应的 Segment 数组的下标，使用ReentrantLock的tryLock（）进行抢占锁</li><li>再通过 hash 值计算出它在对应 Segment 的 HashEntry数组 的下标</li><li>找到合适的位置使用CAS插入元素</li></ol><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>当 put 方法时，发现元素个数超过了阈值，则会扩容。需要注意的是，每个Segment只管它自己的扩容，互相之间并不影响。换句话说，可以出现这个 Segment的长度为2，另一个Segment的长度为4的情况（只要是2的n次幂）。</p><p>JDK7中的ConcurrentHashMap和JDK7的HashMap的扩容是不太一样的，首先JDK7中也是支持多线程扩容的，原因是，JDK7中的ConcurrentHashMap分段了，每一段叫做Segment对象，每个Segment对象相当于一个HashMap，分段之后，对于ConcurrentHashMap而言，能同时支持多个线程进行操作，前提是这些操作的是不同的Segment，而ConcurrentHashMap中的扩容是仅限于本Segment，也就是对应的小型HashMap进行扩容，所以是可以多线程扩容的。</p><p>每个Segment内部的扩容逻辑和HashMap中一样。</p><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/20180920225826285" alt="JDK8 ConcurrentHashMap"></p><p>JDK 1.8 的 CHM（ConcurrentHashMap） 实现，完全重构了 1.7 。<strong>不再有 Segment 的概念</strong>，只是为了兼容 1.7 才申明了一下，并没有用到。因此，<strong>不再使用分段锁，而是给数组中的每一个头节点</strong>（为了方便，以后都叫桶）都加锁，<strong>锁的粒度降低了</strong>。并且，用的是 Synchronized 锁。</p><p>JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//  扩容用  计算扩容生成一个标识戳</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<span class="hljs-comment">// 65535 标识并发扩容最大线程数量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RESIZERS</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">32</span> - RESIZE_STAMP_BITS)) - <span class="hljs-number">1</span>;<span class="hljs-comment">// 扩容相关</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_SHIFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span> - RESIZE_STAMP_BITS;<span class="hljs-comment">// node 结点的hash 是-1 表示 当前结点是forwardingNode结点</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOVED</span>     <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// hash for forwarding nodes</span><span class="hljs-comment">// 红黑树的代理结点</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEBIN</span>   <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>; <span class="hljs-comment">// hash for roots of trees</span><span class="hljs-comment">// 临时保留的散列表</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESERVED</span>  <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>; <span class="hljs-comment">// hash for transient reservations</span><span class="hljs-comment">// 0x7fffffff = 31个1  用于将一个负数变成一个正数 但是不是取绝对值</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// usable bits of normal node hash</span><span class="hljs-comment">// 系统cpu数量</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NCPU</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<span class="hljs-comment">// 散列表</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="hljs-comment">// 扩容用的临时散列表</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="hljs-comment">// LongAdder 的baseCount </span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> baseCount;<span class="hljs-comment">/**</span><span class="hljs-comment">sizeCtl &lt;0 </span><span class="hljs-comment">1. -1 的时候 表示table正在初始化(有线程正在初始化 ， 当前线程应该自旋等待)</span><span class="hljs-comment">2. 其他情况 表示当前map正在进行扩容 高16位表示 扩容的标识戳 ， 低16位表示 扩容线程数量</span><span class="hljs-comment">sizeCtl = 0 </span><span class="hljs-comment">表示创建数组 使用默认容量 16</span><span class="hljs-comment">sizeCtl &gt;0</span><span class="hljs-comment">1. 如果table 未初始化 表示 初始化大小</span><span class="hljs-comment">2. 如果table 已经初始化 表示下次扩容的阈值</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<span class="hljs-comment">//扩容过程中，记录当前进度，所有线程都需要从transferIndex中分配区间任务，去执行自己的任务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> transferIndex;<span class="hljs-comment">// 0 表示 无锁 1 表示加锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy; <span class="hljs-comment">// LongAdder 中的cells 数组 当baseCount发生竞争后 会创建cells 数组</span> <span class="hljs-comment">// 线程会通过计算hash值 取到自己的cell中</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> CounterCell[] counterCells;<span class="hljs-comment">//标记作用，表示其他线程正在扩容，并且此节点已经扩容完毕</span><span class="hljs-comment">//关联了nextTable,扩容期间可以通过find方法，访问已经迁移到了nextTable中的数据</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;        <span class="hljs-comment">//hash值为MOVED（-1）的节点就是ForwardingNode</span>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        <span class="hljs-built_in">this</span>.nextTable = tab;    &#125;    <span class="hljs-comment">//通过此方法，访问被迁移到nextTable中的数据</span>    Node&lt;K,V&gt; <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> h, Object k)</span> &#123;        ...    &#125;&#125;</code></pre></div><h4 id="Put（）-1"><a href="#Put（）-1" class="headerlink" title="Put（）"></a>Put（）</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);&#125;<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;    <span class="hljs-comment">//可以看到，在并发情况下，key 和 value 都是不支持为空的。</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();    <span class="hljs-comment">//这里和1.8 HashMap 的hash 方法大同小异</span>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());    <span class="hljs-comment">//用来计算当前链表上的元素个数</span>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;        <span class="hljs-comment">//若表为空，则说明还未初始化。</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            <span class="hljs-comment">//初始化表，只有一个线程可以初始化成功。</span>            tab = initTable();        <span class="hljs-comment">//若表已经初始化，则找到当前 key 所在的桶，并且判断是否为空</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//若当前桶为空，则通过 CAS 原子操作，把新节点插入到此位置，</span>            <span class="hljs-comment">//这保证了只有一个线程可以 CAS 成功，其它线程都会失败。</span>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">//若所在桶不为空，则判断节点的 hash 值是否为 MOVED（值是-1）</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            <span class="hljs-comment">//若为-1，说明当前数组正在进行扩容，则需要当前线程帮忙迁移数据</span>            tab = helpTransfer(tab, f);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-comment">//这里用加同步锁的方式，来保证线程安全，给桶中第一个节点对象加锁</span>            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-comment">//recheck 一下，保证当前桶的第一个节点无变化，后边很多这样类似的操作，不再赘述</span>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-comment">//如果hash值大于等于0，说明是正常的链表结构</span>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-comment">//从头结点开始遍历，每遍历一次，binCount计数加1</span>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-comment">//如果找到了和当前 key 相同的节点，则用新值替换旧值</span>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-comment">//若遍历到了尾结点，则把新节点尾插进去</span>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,                                                          value, <span class="hljs-literal">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">//否则判断是否是树节点。这里提一下，TreeBin只是头结点对TreeNode的再封装</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                              value)) != <span class="hljs-literal">null</span>) &#123;                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//注意下，这个判断是在同步锁外部，因为 treeifyBin内部也有同步锁，并不影响</span>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//如果节点个数大于等于 8，则转化为红黑树</span>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                <span class="hljs-comment">//把旧节点值返回</span>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//给元素个数加 1，并有可能会触发扩容，比较复杂，稍后细讲</span>    addCount(<span class="hljs-number">1L</span>, binCount);    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h4 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer()方法"></a>transfer()方法</h4><p>扩容方法</p><p><img src="/2022/03/15/map/HashMap%E5%8F%8ACurrentHashMap/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMTY1MGYwYjMzMzFmMTBlNWFlMDE1ODczNTQwNDgucG5n" alt="其他线程帮助扩容"></p><p>为了方便，上边以原数组长度 8 为例。在元素迁移的时候，所有线程都遵循从后向前推进的规则，即如图A线程是第一个进来的线程，会从下标为7的位置，开始迁移数据。</p><p>而且当前线程迁移时会确定一个范围，限定它此次迁移的数据范围，如图 A 线程只能迁移 bound&#x3D;6到 i&#x3D;7 这两个数据。</p><p>此时，其它线程就不能迁移这部分数据了，只能继续向前推进，寻找其它可以迁移的数据范围，且每次推进的步长为固定值 stride（此处假设为2）。如图中 B线程发现 A 线程正在迁移6,7的数据，因此只能向前寻找，然后迁移 bound&#x3D;4 到 i&#x3D;5 的这两个数据。</p><p>当每个线程迁移完成它的范围内数据时，都会继续向前推进。那什么时候是个头呢？</p><p>这就需要维护一个全局的变量 transferIndex，来表示所有线程总共推进到的元素下标位置。如图，线程 A 第一次迁移成功后又向前推进，然后迁移2,3 的数据。此时，若没有其他线程在帮助迁移，则 transferIndex 即为2。</p><p>剩余部分等待下一个线程来迁移，或者有任何的 A 和B线程已经迁移完成，也可以推进到这里帮助迁移。直到 transferIndex&#x3D;0 。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个类是一个标志，用来代表当前桶（数组中的某个下标位置）的元素已经全部迁移完成</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;        <span class="hljs-comment">//把当前桶的头结点的 hash 值设置为 -1，表明已经迁移完成，</span>        <span class="hljs-comment">//这个节点中并不存储有效的数据</span>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        <span class="hljs-built_in">this</span>.nextTable = tab;    &#125;&#125;<span class="hljs-comment">//迁移数据</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;    <span class="hljs-comment">//根据当前CPU核心数，确定每次推进的步长，最小值为16.（为了方便我们以2为例）</span>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span>    <span class="hljs-comment">//从 addCount 方法，只会有一个线程跳转到这里，初始化新数组</span>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            <span class="hljs-comment">//新数组长度为原数组的两倍</span>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];            nextTab = nt;        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span>            sizeCtl = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//用 nextTable 指代新数组</span>        nextTable = nextTab;        <span class="hljs-comment">//这里就把推进的下标值初始化为原数组长度（以16为例）</span>        transferIndex = n;    &#125;    <span class="hljs-comment">//新数组长度</span>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;    <span class="hljs-comment">//创建一个标志类</span>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);    <span class="hljs-comment">//是否向前推进的标志</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//是否所有线程都全部迁移完成的标志</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span>    <span class="hljs-comment">//i 代表当前线程正在迁移的桶的下标，bound代表它本次可以迁移的范围下限</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;        <span class="hljs-comment">//需要向前推进</span>        <span class="hljs-keyword">while</span> (advance) &#123;            <span class="hljs-type">int</span> nextIndex, nextBound;            <span class="hljs-comment">// (1) 先看 (3) 。i每次自减 1，直到 bound。若超过bound范围，或者finishing标志为true，则不用向前推进。</span>            <span class="hljs-comment">//若未全部完成迁移，且 i 并未走到 bound，则跳转到 (7)，处理当前桶的元素迁移。</span>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)                advance = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// (2) 每次执行，都会把 transferIndex 最新的值同步给 nextIndex</span>            <span class="hljs-comment">//若 transferIndex小于等于0，则说明原数组中的每个桶位置，都有线程在处理迁移了，</span>            <span class="hljs-comment">//于是，需要跳出while循环，并把 i设为 -1，以跳转到④判断在处理的线程是否已经全部完成。</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;                i = -<span class="hljs-number">1</span>;                advance = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-comment">// (3) 第一个线程会先走到这里，确定它的数据迁移范围。(2)处会更新 nextIndex为 transferIndex 的最新值</span>            <span class="hljs-comment">//因此第一次 nextIndex=n=16，nextBound代表当次迁移的数据范围下限，减去步长即可，</span>            <span class="hljs-comment">//所以，第一次时，nextIndex=16，nextBound=16-2=14。后续，每次都会间隔一个步长。</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,                      nextBound = (nextIndex &gt; stride ?                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;                <span class="hljs-comment">//bound代表当次数据迁移下限</span>                bound = nextBound;                <span class="hljs-comment">//第一次的i为15，因为长度16的数组，最后一个元素的下标为15</span>                i = nextIndex - <span class="hljs-number">1</span>;                <span class="hljs-comment">//表明不需要向前推进，只有当把当前范围内的数据全部迁移完成后，才可以向前推进</span>                advance = <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-comment">// (4)</span>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;            <span class="hljs-type">int</span> sc;            <span class="hljs-comment">//若全部线程迁移完成</span>            <span class="hljs-keyword">if</span> (finishing) &#123;                nextTable = <span class="hljs-literal">null</span>;                <span class="hljs-comment">//更新table为新表</span>                table = nextTab;                <span class="hljs-comment">//扩容阈值改为原来数组长度的 3/2 ，即新长度的 3/4，也就是新数组长度的0.75倍</span>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//到这，说明当前线程已经完成了自己的所有迁移（无论参与了几次迁移），</span>            <span class="hljs-comment">//则把 sc 减1，表明参与扩容的线程数减少 1。</span>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;                <span class="hljs-comment">//在 addCount 方法最后，我们强调，迁移开始时，会设置 sc=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span>                <span class="hljs-comment">//每当有一个线程参与迁移，sc 就会加 1，每当有一个线程完成迁移，sc 就会减 1。</span>                <span class="hljs-comment">//因此，这里就是去校验当前 sc 是否和初始值是否相等。相等，则说明全部线程迁移完成。</span>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    <span class="hljs-keyword">return</span>;                <span class="hljs-comment">//只有此处，才会把finishing 设置为true。</span>                finishing = advance = <span class="hljs-literal">true</span>;                <span class="hljs-comment">//这里非常有意思，会把 i 从 -1 修改为16，</span>                <span class="hljs-comment">//目的就是，让 i 再从后向前扫描一遍数组，检查是否所有的桶都已被迁移完成，参看 (6)</span>                i = n; <span class="hljs-comment">// recheck before commit</span>            &#125;        &#125;        <span class="hljs-comment">// (5) 若i的位置元素为空，则说明当前桶的元素已经被迁移完成，就把头结点设置为fwd标志。</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);        <span class="hljs-comment">// (6) 若当前桶的头结点是 ForwardingNode ，说明迁移完成，则向前推进 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span>        <span class="hljs-comment">//(7) 处理当前桶的数据迁移。</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">synchronized</span> (f) &#123;  <span class="hljs-comment">//给头结点加锁</span>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    Node&lt;K,V&gt; ln, hn;                    <span class="hljs-comment">//若hash值大于等于0，则说明是普通链表节点</span>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;                        <span class="hljs-comment">//这里是 1.7 的 CHM 的 rehash 方法和 1.8 HashMap的 resize 方法的结合体。</span>                        <span class="hljs-comment">//会分成两条链表，一条链表和原来的下标相同，另一条链表是原来的下标加数组长度的位置</span>                        <span class="hljs-comment">//然后找到 lastRun 节点，从它到尾结点整体迁移。</span>                        <span class="hljs-comment">//lastRun前边的节点则单个迁移，但是需要注意的是，这里是头插法。</span>                        <span class="hljs-comment">//另外还有一点和1.7不同，1.7 lastRun前边的节点是复制过去的，而这里是直接迁移的，没有复制操作。</span>                        <span class="hljs-comment">//所以，最后会有两条链表，一条链表从 lastRun到尾结点是正序的，而lastRun之前的元素是倒序的，</span>                        <span class="hljs-comment">//另外一条链表，从头结点开始就是倒叙的。看下图。</span>                        Node&lt;K,V&gt; lastRun = f;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;                            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;                            <span class="hljs-keyword">if</span> (b != runBit) &#123;                                runBit = b;                                lastRun = p;                            &#125;                        &#125;                        <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;                            ln = lastRun;                            hn = <span class="hljs-literal">null</span>;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            hn = lastRun;                            ln = <span class="hljs-literal">null</span>;                        &#125;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;                            <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;                            <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)                                ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);                            <span class="hljs-keyword">else</span>                                hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);                        &#125;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = <span class="hljs-literal">true</span>;                    &#125;                    <span class="hljs-comment">//树节点</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                        TreeNode&lt;K,V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                        <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;                            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;                            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;                                (h, e.key, e.val, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);                            <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;                                <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-literal">null</span>)                                    lo = p;                                <span class="hljs-keyword">else</span>                                    loTail.next = p;                                loTail = p;                                ++lc;                            &#125;                            <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-literal">null</span>)                                    hi = p;                                <span class="hljs-keyword">else</span>                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            &#125;                        &#125;                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                        (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                        (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = <span class="hljs-literal">true</span>;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h4 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer()"></a>helpTransfer()</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;    Node&lt;K,V&gt;[] nextTab; <span class="hljs-type">int</span> sc;    <span class="hljs-comment">//头结点为 ForwardingNode ，并且新数组已经初始化</span>    <span class="hljs-keyword">if</span> (tab != <span class="hljs-literal">null</span> &amp;&amp; (f <span class="hljs-keyword">instanceof</span> ForwardingNode) &amp;&amp;        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(tab.length);        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;               (sc = sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//若校验标识失败，或者已经扩容完成，或推进下标到头，则退出</span>            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">//当前线程需要帮助迁移，sc值加1</span>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;                transfer(tab, nextTab);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> nextTab;    &#125;    <span class="hljs-keyword">return</span> table;&#125;</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在JDK8中，ConcurrentHashMap几乎全面改写</p><ol><li>Segment的代码虽然还存在，但是已经没有实际效果了，只是为了兼容JDK7</li><li>锁的粒度变得更小了，以前是通过锁Segment，现在移除了segment后变成了直接锁表头，效率变得更高了</li><li>锁的实现也改变了，以前锁segment的使用ReentrantLock并使用cas进行修改，JDK8变成了使用Synchronized 锁表头，由于Synchronized 进行优化后有了锁升级的过程所以效率并不低</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的学习笔记</title>
    <link href="/2021/09/05/redis/Redis/"/>
    <url>/2021/09/05/redis/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis详解"><a href="#Redis详解" class="headerlink" title="Redis详解"></a>Redis详解</h1><h2 id="Redis数据类型应用"><a href="#Redis数据类型应用" class="headerlink" title="Redis数据类型应用"></a>Redis数据类型应用</h2><ol><li>string<ul><li>分布式锁</li><li>记录点赞、喜欢。利用Redis中原子性的自增操作，可以用使用实现计算器的功能，比如统计用户点赞数、用户访问数等，这类操作如果用MySQL，<strong>频繁的读写会带来相当大的压力</strong>。</li><li>商品编号、订单号采用INCR命令生成</li></ul></li><li>list<ul><li>文章订阅</li><li>关注了大V，他们发布的文章会推送到用户<ul><li>ipush likearticle_uid 文章号</li><li>lrange likearticle_uid 0 10   （0 10是分页）</li></ul></li></ul></li><li>hash<ul><li>对应Map&lt;String , Map&lt;Object , Object&gt;&gt;</li><li>可以作为购物车使用<ul><li>hset 335500_shopcar 123 1添加商品</li><li>hset 335500_shopcar 124 1        添加商品</li><li>hincrby 335500_shopcar 123 1    增加购买数量</li></ul></li></ul></li><li>set（有序不可重复）<ul><li>运算<ul><li>差集运算 SDIFF key [key …]</li><li>交集运算 SINTER key [key …]</li><li>并集运算 SUNION key [key …]</li></ul></li><li>微信抽奖</li><li>微信朋友圈点赞</li><li>查询共同关注（交集运算）</li><li>QQ可能认识的人（交集运算）</li></ul></li><li>zset（有序不可重复可排序）<ul><li>商品销售排行榜</li><li>热搜排行</li></ul></li><li>bitmap</li><li>HyperLogLogs</li><li>GEO</li><li>Stream</li></ol><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p>Redis的读写操作都是基于单线程的无须多言。<strong>那怎么监听大量的客户端连接呢</strong>？</p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="/2021/09/05/redis/Redis/redis-event-handler.png" alt="Redis的文件事务处理器"></p><p>一个完整的流程如下</p><p><img src="/ihsq498l5m.png"><img src="/1xylt0ue9b.png"><img src="/itewmdx73z.png"></p><p>多路复用监听各个socket，将socket压入队列，由事件分配器取。而非如MySQL需要为每个连接创建一个线程。<strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈。</p><p>优点：</p><ol><li>使用多路复用能够提高IO效率，同时又减少监听各个Socket的消耗</li><li>读写仍然是单线程，不需要线程切换</li><li>没有同步的问题，不需要有锁</li></ol><p><strong>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</strong></p><h2 id="Redis操作原子性的保障"><a href="#Redis操作原子性的保障" class="headerlink" title="Redis操作原子性的保障"></a>Redis操作原子性的保障</h2><h3 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h3><p>判断并删除</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]<span class="hljs-keyword">then</span>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><span class="hljs-keyword">end</span></code></pre></div><p>使用Jedis实现lua脚本的使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//连接jedis</span><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> RedisUtils.getJedis();<span class="hljs-comment">//设置lua脚本</span><span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span>    + <span class="hljs-string">&quot;then &quot;</span>    + <span class="hljs-string">&quot;    return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span>    + <span class="hljs-string">&quot;else &quot;</span>    + <span class="hljs-string">&quot;    return 0 &quot;</span>    + <span class="hljs-string">&quot;end&quot;</span>;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//调用脚本，参数1：lua脚本 ， 参数2：list包装的key参数列表，参数3：list包装的value列表</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> jedis.eval(script, Collections.singletonList(REDIS_LOCK),                          Collections.singletonList(value));<span class="hljs-comment">//判断结果</span>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;1&quot;</span>.equals(o.toString())) &#123;        System.out.println(<span class="hljs-string">&quot;---del redis lock ok.&quot;</span>);    &#125;<span class="hljs-keyword">else</span> &#123;        System.out.println(<span class="hljs-string">&quot;---del redis lock error.&quot;</span>);    &#125;&#125;<span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span>(jedis != <span class="hljs-literal">null</span>)         jedis.close();&#125;</code></pre></div><h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><p>命令</p><ol><li>MULTI：标记事务的开始，接下来的命令会入队</li><li>EXEC：提交事务，然会恢复到正常连接状态</li><li>DISCARD：清楚当前事务中所有已经入队的命令，然会恢复到正常连接状态</li><li>WATCH：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li><li>UNWATCH：取消监视所有的key</li></ol><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch k1OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k2 2QUEUED127.0.0.1:6379&gt; set k1 1QUEUED127.0.0.1:6379&gt; execOKOK</code></pre></div><p>在Java中实现事务</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//监听key</span>stringRedisTemplate.watch(REDIS_LOCK);<span class="hljs-keyword">if</span>(stringRedisTemplate.opsForValue().get(REDIS_LOCK).equalsIgnoreCase(value))&#123;    <span class="hljs-comment">//开启事务支持</span>    stringRedisTemplate.setEnableTransactionSupport(<span class="hljs-literal">true</span>);<span class="hljs-comment">//开启事务</span>    stringRedisTemplate.multi();    <span class="hljs-comment">//删除key</span>    stringRedisTemplate.delete(REDIS_LOCK);    <span class="hljs-comment">//执行事务，list接受返回结果</span>    List&lt;Object&gt; list = stringRedisTemplate.exec();    <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">continue</span>;    &#125;&#125;<span class="hljs-comment">//解除监听</span>stringRedisTemplate.unwatch();<span class="hljs-keyword">break</span>;</code></pre></div><h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h3><p>不仅可以实现原子性，而且还是分布式的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取该key的可重入锁</span><span class="hljs-type">RLock</span> <span class="hljs-variable">redissonLock</span> <span class="hljs-operator">=</span> redisson.getLock(LOCK_KEY);<span class="hljs-comment">//上锁</span>redissonLock.lock();<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>操作redis</span>&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//判断仍然锁着，判断是当前线程持有锁</span>    <span class="hljs-keyword">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread()) &#123;        <span class="hljs-comment">//解锁    </span>        redissonLock.unlock();    &#125;&#125;</code></pre></div><p>redisson分布式锁的特性</p><ol><li>自动续期：如果到了一定的时间还没有完成业务，redisson的看门狗机制会自动续期</li></ol><h2 id="Redis内存"><a href="#Redis内存" class="headerlink" title="Redis内存"></a>Redis内存</h2><h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><ol><li>redis在64位操作系统下默认无限大，即内存空间多大就有多大，32位为3G。一般推荐设置为最大物理内存的3&#x2F;4.</li><li>配置redis内存大小<ul><li>redis.conf下配置 maxmemory 以字节为单位</li><li>命令设置 config set maxmemory 字节数</li></ul></li><li>如果超出了redis最大内存，会报OOM错误</li></ol><h3 id="Redis的过期删除策略"><a href="#Redis的过期删除策略" class="headerlink" title="Redis的过期删除策略"></a>Redis的过期删除策略</h3><ol><li><p>定时删除：到了时间就删除，这样对CPU消耗过大。需要时时遍历所有被设置了过期时间的数据。</p></li><li><p>惰性删除：到期也不立即删除，等到下一次访问的时候再判断是否过期，过期返回空并删除。这种方法对内存不友好，如果一个过期数据太久没有被访问到，就会一直存在内存中，造成内存泄漏。</p></li><li><p>定期删除：周期性抽查redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频率</p><ul><li>抽查频率可以自定义</li><li>内存压力不是很大，长期占用内存的冷数据会被持续清理</li></ul><p> 注：一般采取惰性删除及定期删除结合使用，但是有可能有数据一直没有被访问，且一直没有抽查到。所以需要一个兜底方案，即缓存淘汰策略</p></li></ol><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><ul><li>noeviction（默认）：不会驱逐任何key</li><li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li><li>volatile-Iru：对所有设置了过期时间的key使用LRU算法进行删除</li><li>volatile-random：对所有设置了过期时间的key随机删除</li><li>volatile-ttl：删除马上要过期的key</li><li>allkeys-lfu：对所有key使用LFU算法进行删除</li><li>allkeys-Iru（推荐）：对所有key使用LRU算法进行删除</li><li>allkeys-random：对所有key随机删除</li></ul><p>两个维度</p><ul><li>过期键</li><li>所有键</li></ul><p>四个方面</p><ul><li>LRU：最近最久未使用</li><li>LFU：最少频率使用</li><li>random：随机</li><li>ttl：删除马上过期</li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF(appenf Only File)持久化是把每次写命令追加写入日志中，当需要恢复数据时重新执行AOF文件中的命令，实现数据持久化的<strong>实时性</strong></p><h4 id="AOF流程"><a href="#AOF流程" class="headerlink" title="AOF流程"></a>AOF流程</h4><p><img src="/2021/09/05/redis/Redis/20200406103514987.jpg" alt="AOF流程"></p><ol><li>命令追加（append）：所有写命令都会被追加到AOF缓存区（aof_buf）中</li><li>文件同步（sync）：根据不同策略将AOF缓冲区同步到AOF文件中</li><li>文件重写（rewrite）：定期对AOF文件进行重写，以达到压缩的目的</li><li>数据加载（load）：当需要恢复数据时，重写执行AOF文件中的命令</li></ol><h4 id="AOF文件同步策略"><a href="#AOF文件同步策略" class="headerlink" title="AOF文件同步策略"></a>AOF文件同步策略</h4><ol><li>always：每次写入缓存区都要同步到AOF文件中，硬盘的操作比较慢，限制了redis的高并发</li><li>no：每次写入缓存区后不立即进行同步，同步到AOF文件的操作由操作系统负责，每次同步AOF文件的周期不可控，而且增大了每次同步的硬盘数据量</li><li>eversec（默认、建议）：每次写入缓存区后，由专门的线程每秒钟同步一次，做到兼顾性能和数据安全</li></ol><h4 id="触发文件重写"><a href="#触发文件重写" class="headerlink" title="触发文件重写"></a>触发文件重写</h4><p>AOF持久化流程中文件重写可以手动触发，也可以自动触发</p><ol><li>手动触发：使用bbgrewriteaof命令</li><li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage配置确定自动触发的时机。auto-aof-rewrite-min-size表示运行AOF重写时文件大小的最小值，默认为64MB；auto-aof-rewrite-percentage表示当前AOF文件大小和上一次重写后AOF文件大小的比值的最小值，默认为100。只用前两者同时超过时才会自动触发文件重写。</li></ol><h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># appendonly改为yes，开启AOF</span><span class="hljs-string">appendonly</span> <span class="hljs-literal">yes</span><span class="hljs-comment"># AOF文件的名字</span><span class="hljs-string">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><span class="hljs-comment"># AOF文件的写入方式</span><span class="hljs-comment"># everysec 每个一秒将缓存区内容写入文件 默认开启的写入方式</span><span class="hljs-string">appendfsync</span> <span class="hljs-string">everysec</span><span class="hljs-comment"># 运行AOF重写时AOF文件大小的增长率的最小值</span><span class="hljs-string">auto-aof-rewrite-percentage</span> <span class="hljs-number">100</span><span class="hljs-comment"># 运行AOF重写时文件大小的最小值</span><span class="hljs-string">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb</span></code></pre></div><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB（Redis DataBase）持久化是把当前Redis中全部数据生成快照保存到硬盘上。RDB可以手动触发也可以自动触发，策略分为save（阻塞式）和bgsave（非阻塞式）</p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>save流程：就是由Redis进程进行快照生成</p><p>bgsave流程:</p><p><img src="/2021/09/05/redis/Redis/20200405214335983.jpg" alt="bgsave命令流程"></p><ol><li>执行<strong>bgsave</strong>命令，Redis进程先判断当前是否存在正在执行的RDB或AOF子线程，如果存在直接结束本次同步</li><li>Redis进程执行<strong>fork</strong>操作创建子线程，在fork的过程中Redis进程会被<strong>阻塞</strong></li><li>Redis进程fork结束后bgsave命令就结束了，此后redis进程不再被阻塞</li><li>子线程会根据Redis进程的内存生成快照，替换原来的RDB文件</li><li>子线程通过信号量通知Redis进程已完成</li></ol><h4 id="RDB触发持久化"><a href="#RDB触发持久化" class="headerlink" title="RDB触发持久化"></a>RDB触发持久化</h4><ol><li>手动触发：save和bgsave命令都可以触发RDB持久化</li><li>自动触发：采用bgsave的方式<ul><li>在配置文件中设置了save相关配置，如save m n ，表示在m秒内被修改过n次，就自动触发bgsave</li><li>当节点做全量复制时，主节点会自动执行bgsave操作，并且把生成的rdb文件发给从节点</li><li>执行debug reload命令时会自动触发bgsave操作</li><li>执行shutdown命令时，如果没有开启AOF持久化的化就会自动触发bgsave</li></ul></li></ol><h4 id="RDB特点"><a href="#RDB特点" class="headerlink" title="RDB特点"></a>RDB特点</h4><ul><li>优点：RDB文件是一个紧凑的二进制压缩文件，是redis在某个时间点全部的数据快照，所有使用RDB恢复数据的速度比AOF快，非常适合备份、全量复制、灾难恢复等场景</li><li>缺点：每次进行bgsave操作都要执行fork操作都要创建子线程，属于重量级操作，成本过高，只能定期使用。无法做到数据的实时性。且高版本redis的rdb可能无法兼容低版本rdb</li></ul><h2 id="穿透、击穿、雪崩"><a href="#穿透、击穿、雪崩" class="headerlink" title="穿透、击穿、雪崩"></a>穿透、击穿、雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库</p><p>通俗的来说：访问的数据缓存找不到，一直转而发送到数据库</p><p><img src="/2021/09/05/redis/Redis/af684a6b66014b548b1bee6a84796a61.png" alt="缓存穿透"></p><p>解决方案</p><ol><li>空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li><li>设置白名单：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮</p><p><img src="/2021/09/05/redis/Redis/39bdefa3829a490cb1609730e90619ba.png" alt="缓存击穿"></p><p>解决方案</p><ol><li>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li><li>实时调整：现场监控哪些数据热门，实时调整key的过期时长</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量热点数据同时过期，此时若有大量并发请求过来，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>解决方案</p><ol><li>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li><li>将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li><li>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</li></ol><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的master&#x2F;slaver机制，Master（主机）以写为主，Slave（从机）以读为主</p><p><img src="/2021/09/05/redis/Redis/6686324784654d88acea396c515b3ca5.png" alt="主从复制示意图"></p><p>主要功能：</p><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>Slave启动成功连接到master后，从机slave会发送一个sync（同步）命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。（刚开始从机连接主机，主机一次给）</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步 （主机修改了数据会给予从机修改的数据同步，叫做增量复制）</li></ol><h3 id="宕机"><a href="#宕机" class="headerlink" title="宕机"></a>宕机</h3><ul><li>主机宕机：主机宕机，从机仍然不会改变主机设置，不过会知道主机宕机了</li><li>从机宕机：从机宕机，从连后会从新向主机完全同步一次（全量复制）</li></ul><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>复制redis.conf到一个目录下，并创建redis6379.conf、redis6380.conf、redis6381.conf</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">文件</span>-rw-r--r--. 1 root root   337 10月  9 19:25 redis6379.conf-rw-r--r--. 1 root root   340 10月  9 19:24 redis6380.conf-rw-r--r--. 1 root root   340 10月  9 19:25 redis6381.conf-rw-r--r--. 1 root root 62209 10月  9 16:47 redis.conf<span class="hljs-meta prompt_">#</span><span class="language-bash">以redis6379.conf为例</span>include /opt/redis-5.0.2/myredis/redis.confpidfile /var/run/redis_6379.pidport 6379dbfilename &quot;dump6379.rdb&quot;<span class="hljs-meta prompt_">#</span><span class="language-bash">启动3台服务器 redis-server 配置文件</span>redis-server redis6379.confredis-server redis6380.confredis-server redis6381.conf<span class="hljs-meta prompt_">#</span><span class="language-bash">登录 redis-cli -p 端口号</span>redis-cli -p 6379redis-cli -p 6380redis-cli -p 6381<span class="hljs-meta prompt_">#</span><span class="language-bash">设置6380、6381为从机 slaveof &lt;ip&gt;&lt;port&gt;</span>slaveof 127.0.0.1 6379</code></pre></div><h3 id="多级主从"><a href="#多级主从" class="headerlink" title="多级主从"></a>多级主从</h3><p>如果有很多redis搭建主从，可以使用多级主从的方式搭建。上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p><p>用 <code>slaveof &lt;ip&gt;&lt;port&gt;</code> ，中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><h3 id="从机变为主机"><a href="#从机变为主机" class="headerlink" title="从机变为主机"></a>从机变为主机</h3><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改</p><p>可以使用命令：<code>slaveof no one</code> 将从机变为主机，但是原来的其他从机不会认新的主机，还是保持原来的连接主机。且原主机重启后也还是主机。</p><h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><p>哨兵节点功能是监控<code>redis</code>集群，通常不会只用一个哨兵，而是采用哨兵集群。哨兵集群中会有一个<strong>哨兵领导者</strong>。</p><p>哨兵领导者在 Redis 哨兵中扮演着非常重要的角色，其作用主要有以下几点：</p><ol><li>管理哨兵集群：哨兵领导者 负责管理整个哨兵集群，包括所有哨兵节点的状态信息、主节点和从节点的状态信息等。它会定期发送心跳信号来检测哨兵节点的状态，并根据响应来更新哨兵集群的状态信息。</li><li>选举主节点：当主节点失效时，哨兵领导者 负责协调哨兵集群完成新主节点的选举。它会向其他哨兵节点发起请求，通过投票机制选出新的主节点，并通知所有从节点切换到新主节点上。</li><li>故障转移：除了选举主节点外，当从节点或哨兵节点出现故障时，哨兵领导者 也负责协调哨兵集群完成故障转移。它会检测故障节点的状态，并指示其他节点执行相应的操作，例如将从节点提升为主节点或启动新的从节点等。</li><li>维护系统稳定性：最重要的一点是，哨兵领导者 的存在可以帮助保证 哨兵领导者 系统的高可用性和稳定性。它通过对哨兵集群的管理和协调，以及对主节点和从节点的监控和维护，可以快速响应故障，并自动完成故障转移，避免系统 downtime。</li></ol><h3 id="哨兵领导者的选举"><a href="#哨兵领导者的选举" class="headerlink" title="哨兵领导者的选举"></a>哨兵领导者的选举</h3><p>为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。</p><p>任何一个想成为 Leader 的哨兵，要满足两个条件</p><ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 <code>quorum </code>值。</li></ul><blockquote><p>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主机“客观下线”？能否自动切换？</p><p>1、哨兵集群可以判定主机“主观下线”。由于<code>quorum</code>&#x3D;2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了<code>quorum</code>的值，因此，<strong>哨兵集群可以判定主库为“客观下线”</strong>。</p><p>2、<strong>但哨兵不能完成主从切换</strong>。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5&#x2F;2+1&#x3D;3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到<code>N/2+1</code>选票的结果,于是1永远无法产生领导者。</p></blockquote><h3 id="新主机的诞生"><a href="#新主机的诞生" class="headerlink" title="新主机的诞生"></a>新主机的诞生</h3><p>主要是为了监控主机宕机之后，从机可以立马变为主机，不用手动设置。能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p><img src="/2021/09/05/redis/Redis/cd7ac35307e84a09a68ce9b6326b7f5a.png" alt="哨兵"></p><p>首先哨兵节点会定期向主节点发送PING命令，如果在规定的时间内没有收到PONG回复，就认为主节点已经宕机了。然后就会发起投票，如果认为宕机的哨兵数量大于配置文件中<code>quorum</code>配置项，那么就会认为这台主机宕机，由哨兵领导者根据以下原则选出新的主机。</p><ul><li>先选择优先级靠前的（slave-priority 值越小优先级越高）从机</li><li>再选偏移量最大的（同步主机数据最多的）</li><li>最后选择runid最小的从机</li></ul><ol start="2"><li>挑选出新的主机后，哨兵领导者为其他的从机设置新的主机</li><li>原主机重新上线后，哨兵领导者会将它设置为从机</li></ol><p>缺点：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h3 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h3><p>新建一个<code>sentinel.conf</code>文件</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">文件目录</span>-rw-r--r--. 1 root root   409 10月  9 19:32 sentinel.conf<span class="hljs-meta prompt_">#</span><span class="language-bash">内容：哨兵 监控 别名 主机host 端口 至少需要同意票数</span>sentinel monitor mymaster 127.0.0.1 6379 1<span class="hljs-meta prompt_">#</span><span class="language-bash">启动哨兵</span>redis-sentinel sentinel.conf</code></pre></div><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="hljs-literal">null</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Jedis <span class="hljs-title function_">getJedisFromSentinel</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(jedisSentinelPool==<span class="hljs-literal">null</span>)&#123;        <span class="hljs-comment">//配置jedis信息</span>        Set&lt;String&gt; sentinelSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        sentinelSet.add(<span class="hljs-string">&quot;192.168.128.109:6379&quot;</span>);        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();        jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>); <span class="hljs-comment">//最大可用连接数</span>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">//最大闲置连接数</span>        jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">//最小闲置连接数</span>        jedisPoolConfig.setBlockWhenExhausted(<span class="hljs-literal">true</span>); <span class="hljs-comment">//连接耗尽是否等待</span>        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">2000</span>); <span class="hljs-comment">//等待时间</span>        jedisPoolConfig.setTestOnBorrow(<span class="hljs-literal">true</span>); <span class="hljs-comment">//取连接的时候进行一下测试 ping pong</span><span class="hljs-comment">//配置哨兵</span>        jedisSentinelPool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(<span class="hljs-string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);        <span class="hljs-keyword">return</span> jedisSentinelPool.getResource();    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> jedisSentinelPool.getResource();    &#125;&#125;</code></pre></div><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>学习</tag>
      
      <tag>redis</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络分层及TCP协议</title>
    <link href="/2021/05/18/computerNetwork/network/"/>
    <url>/2021/05/18/computerNetwork/network/</url>
    
    <content type="html"><![CDATA[<h2 id="网络模型分层"><a href="#网络模型分层" class="headerlink" title="网络模型分层"></a>网络模型分层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2021/05/18/computerNetwork/network/image-20221015151527590.png" alt="网络模型分层"></p><h3 id="OSI分层"><a href="#OSI分层" class="headerlink" title="OSI分层"></a>OSI分层</h3><p>OSI分层给其他的分层有很大的启发，但是其本身并未用在实际应用中。概述</p><p><img src="/2021/05/18/computerNetwork/network/image-20221015161124552.png" alt="OSI网络分层"></p><h3 id="因特网协议栈分层概述"><a href="#因特网协议栈分层概述" class="headerlink" title="因特网协议栈分层概述"></a>因特网协议栈分层概述</h3><p><img src="/2021/05/18/computerNetwork/network/image-20221015162756089.png" alt="因特网协议栈分层"></p><p><img src="/2021/05/18/computerNetwork/network/image-20221015162825521.png" alt="image-20221015162825521"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层是网络应用程序及它们的应用层协议存留的地方。因特网的应用层包括许多协议，例如HTTP、FTP、SMTP、POP3、DNS。</p><p>应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统 中的应用程序交换信息分组。我们把这种位于应用层的信息分组称为报文（message）。</p><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>因特网的<strong>运输层在应用程序端点之间传送应用层报文</strong>。在因特网中，有两种运输协 议，即<strong>TCP</strong>和<strong>UDP</strong>，利用其中的任一个都能运输应用层报文。<strong>TCP</strong>向它的应用程序<strong>提供了面向连接的服务</strong>。<strong>这种服务包括了应用层报文向目的地的确保传递和流量控制</strong>（即发送 方&#x2F;接收方速率匹配）。TCP也将长报文划分为短报文，并提供<strong>拥塞控制机制</strong>，因此当网络拥塞时，源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。在本书中，我们把运输层的分组称为报文段 (segment) 。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>因特网的网络层<strong>负责将称为数据报（datagram）的网络层分组从一台主机移动到另一 台主机</strong>。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段 和目的地址。因特网的网络层包括著名的网际协议IP,该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。这一层包括<strong>IP协议</strong>、<strong>RIP、OSFP、BGP协议</strong>（路由选择协议）、<strong>ARP 协议</strong>（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）、<strong>ICMP 协议</strong>（控制报文协议，用于发送控制消息）、<strong>NAT 协议</strong>（网络地址转换协议）</p><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>因特网的网络层通过源和目的地之间的一系列路由器路由数据报。<strong>为了将分组从一个节点（主机或路由器）移动到路径上的下一个节点</strong>，网络层必须依靠该链路层的服务。特 别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个 •节点。在该下一个节点，链路层将数据报上传给网络层。</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，<strong>而物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点</strong>。在这层中的协议仍然是链路相关 的，并且进一步与该链路（例如，双绞铜线、单模光纤）的实际传输媒体相关。例如，以太 网具有许多物理层协议：一个是关于双绞铜线的，另一个是关于同轴电缆的，还有一个是关 于光纤的，等等。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP被称为是面向连接的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，两个进程需要先进行“握手”，即它们需要相互发送预备报文段，以建立确保数据传输的参数（包括初始序号）。</p><p><strong>这种TCP的长连接是一种逻辑上的连接，其共同状态只保留在两个通信端系统的TCP程序中</strong>。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换 机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP 连接完全视而不见，它们看到的只是数据报</p><p><strong>TCP是点对点的，即只能单对单</strong>。两台主机之间有了一条TCP连接，那么应用层数据就可以从进程A流向进程B。</p><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="/2021/05/18/computerNetwork/network/image-20221015170956819.png" alt="TCP报文段结构"></p><p>TCP报文段首部中两个最重要的字段是序号字段和确认号字段。这两个字段是TCP可 靠传输服务的关键部分。</p><p><strong>序号：—个报文段的序号是该报文段首字节的字节流编号。</strong></p><p>TCP把数据看成一个无结构的、有序的字节流。我们从TCP对序号的使用上可以看出 这一点，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。</p><p><img src="/2021/05/18/computerNetwork/network/image-20221015171419682.png" alt="报文段序号"></p><p><strong>确认号：期望下一次收到的下一字节的序号</strong></p><p>主机A在向主机B发送数据的同时，也许也接收来自主机B的数据(都是同一条TCP 连接的一部分)。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机 A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</p><p>假设主机A已收到一个来自主机B的包含字节0 ~535的报文段，以及 另一个包含字节900〜1000的报文段。由于某种原因，主机A还没有收到字节536 - 899的报 文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536 （和其后的字 节）。因此，A到B的下一个报文段将在确认号字段中包含536。因为TCP只确认该流中至第一 个丢失字节为止的字节，所以TCP被称为提供累积确认</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/2021/05/18/computerNetwork/network/image-20221015164153663.png" alt="三次握手"></p><p>一台正在运行在主机（客户）上的进程想与另外一台主机（服务器）上的进程建立一条连接。客户应用进程首先通知客户TCP，它想建立一个与服务器上某个进程的连接。客户中的TCP会用以下方式与服务器中的TCP建立一条TCP连接。</p><ol><li>第一步：客户端的TCP首先向服务端TCP发送一条特殊的数据报。该数据报不包含应用层数据，但是在报文段的首部中的一个标志位SYN被设置为1，另外还有一个随机的client_isn（初始序号）。</li><li>第二步：一旦包含TCP SYN报文段的IP数据到达服务器主机，服务器会提取出SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户端TCP发送运行连接的报文段。这个允许连接到报文段包含3个重要信息，首先，SYN被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn+1。最后，服务器选择自己的初始序号server_isn。这个报文的意思是：“我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn，我同意连接，我的初始序列号是server_isn。”该允许连接报文被称为SYNACK报文</li><li>第三步：在收到SYNACK后，客户也要给该连接分配缓存和变量，客户主机则向服务器发送另外一个报文段，这最后一个报文段对服务器允许连接的报文进行了确认。因为连接已经确认所以SYN为0，在这个阶段可以携带客户到服务器的数据</li></ol><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2021/05/18/computerNetwork/network/image-20221015172632604.png" alt="四次挥手"></p><p>参与一条TCP连接的两个进程中的 任何一个都能终止该连接。当连接结束后, 主机中的“资源”（即缓存和变量）将被释放。举一个例子，假设某客户打算关闭 连接，</p><ol><li>客户应用进程发出一个关闭连接命令。 这个特殊的报文段让其首部中的一个标志位即FIN比特，被设置为 1.</li><li>当服务器接收到该报文段后，就向发送方回送一个确认报文段。</li><li>然后，服务器发送它自己的终止报文段，其FIN比特被置为1。</li><li>最后该客户对这个服务器的终止报文段进行确认。此时，在两台主机上用 于该连接的所有资源都被释放了。</li></ol><h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ol><li>TCP是面向连接的长连接</li><li>点对点的</li><li>具备流量控制功能</li><li>可靠的数据传输</li><li>动态调节超时时间</li><li>拥塞控制：慢启动、拥塞避免、快速恢复</li></ol><h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的功能简单描述，即将分组从一台发送主机移动到一台接收主机。为此，需要使用两种重要的网络功能：</p><p><strong>转发</strong>：当分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。</p><p><strong>路由选择</strong>：当分组从发送方流向发送方时，网络层必须决定这些分组所采用的路由或路径。计算浙西路径的算法即<strong>路由选择算法</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
